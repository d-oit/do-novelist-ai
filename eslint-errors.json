[{"filePath":"D:\\git\\do-novelist-ai\\src\\app\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\code-splitting.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ActionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\AgentConsole.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\AnalyticsProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\GoapVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\MetricsMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\MigrationWizard.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1134,1137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1134,1137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":41,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":41,"endColumn":29,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1174,1174],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1174,1174],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise-returning function provided to attribute where a void return was expected.","line":102,"column":31,"nodeType":"JSXExpressionContainer","messageId":"voidReturnAttribute","endLine":102,"endColumn":46},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise-returning function provided to attribute where a void return was expected.","line":172,"column":27,"nodeType":"JSXExpressionContainer","messageId":"voidReturnAttribute","endLine":172,"endColumn":47}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Migration Wizard Component\r\n * Guides users through migrating their data from IndexedDB to Turso\r\n */\r\nimport { useState, useEffect } from 'react';\n\r\nimport {\r\n  migrateProjectToTurso,\r\n  checkIndexedDBExists,\r\n  clearIndexedDBData,\r\n  type MigrationProgress,\r\n} from '@/lib/database/migration-utility';\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { Button } from '@/shared/components/ui/Button';\r\nimport { Card } from '@/shared/components/ui/Card';\r\nimport { Progress } from '@/shared/components/ui/Progress';\r\n\r\ninterface MigrationWizardProps {\r\n  projectId: string;\r\n  onComplete: () => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nexport const MigrationWizard: React.FC<MigrationWizardProps> = ({\r\n  projectId,\r\n  onComplete,\r\n  onCancel,\r\n}) => {\r\n  const [step, setStep] = useState<'check' | 'migrate' | 'complete'>('check');\r\n  const [hasData, setHasData] = useState(false);\r\n  const [progress, setProgress] = useState<MigrationProgress>({\r\n    total: 0,\r\n    completed: 0,\r\n    errors: 0,\r\n    currentTask: '',\r\n  });\r\n  const [migrating, setMigrating] = useState(false);\r\n  const [results, setResults] = useState<any>(null);\r\n\r\n  useEffect(() => {\r\n    checkForIndexedDBData();\r\n  }, []);\r\n\r\n  const checkForIndexedDBData = async (): Promise<void> => {\r\n    try {\r\n      const exists = await checkIndexedDBExists();\r\n      const hasAnyData = Object.values(exists).some((v) => v);\r\n      setHasData(hasAnyData);\r\n    } catch (error) {\r\n      logger.error('Failed to check IndexedDB', { component: 'MigrationWizard' }, error as Error);\r\n    }\r\n  };\r\n\r\n  const handleMigrate = async (): Promise<void> => {\r\n    setMigrating(true);\r\n    setStep('migrate');\r\n\r\n    try {\r\n      const migrationResults = await migrateProjectToTurso(projectId, setProgress);\r\n      setResults(migrationResults);\r\n      setStep('complete');\r\n    } catch (error) {\r\n      logger.error('Migration failed', { component: 'MigrationWizard' }, error as Error);\r\n    } finally {\r\n      setMigrating(false);\r\n    }\r\n  };\r\n\r\n  const handleClearOldData = async (): Promise<void> => {\r\n    try {\r\n      await clearIndexedDBData();\r\n      logger.info('IndexedDB data cleared', { component: 'MigrationWizard' });\r\n      onComplete();\r\n    } catch (error) {\r\n      logger.error('Failed to clear IndexedDB', { component: 'MigrationWizard' }, error as Error);\r\n    }\r\n  };\r\n\r\n  if (step === 'check') {\r\n    return (\r\n      <Card className=\"p-6 max-w-2xl mx-auto\">\r\n        <h2 className=\"text-2xl font-bold mb-4\">Database Migration</h2>\r\n        <p className=\"mb-4\">\r\n          Novelist.ai now uses Turso cloud database for better sync and reliability. \r\n          {hasData ? ' We detected local data that can be migrated.' : ' No local data detected.'}\r\n        </p>\r\n        \r\n        {hasData ? (\r\n          <div className=\"space-y-4\">\r\n            <div className=\"bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg\">\r\n              <h3 className=\"font-semibold mb-2\">What will be migrated:</h3>\r\n              <ul className=\"list-disc list-inside space-y-1\">\r\n                <li>Characters and relationships</li>\r\n                <li>World-building data (locations, cultures, timelines)</li>\r\n                <li>Version history and branches</li>\r\n                <li>Publishing analytics</li>\r\n                <li>Writing assistant preferences and history</li>\r\n              </ul>\r\n            </div>\r\n            \r\n            <div className=\"flex gap-3\">\r\n              <Button onClick={handleMigrate} disabled={migrating}>\r\n                Start Migration\r\n              </Button>\r\n              <Button onClick={onCancel} variant=\"secondary\">\r\n                Skip for Now\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"flex gap-3\">\r\n            <Button onClick={onComplete}>Continue</Button>\r\n          </div>\r\n        )}\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  if (step === 'migrate') {\r\n    const progressPercent = progress.total > 0 ? (progress.completed / progress.total) * 100 : 0;\r\n\r\n    return (\r\n      <Card className=\"p-6 max-w-2xl mx-auto\">\r\n        <h2 className=\"text-2xl font-bold mb-4\">Migrating Data...</h2>\r\n        <p className=\"mb-4 text-gray-600 dark:text-gray-400\">{progress.currentTask}</p>\r\n        \r\n        <Progress value={progressPercent} className=\"mb-2\" />\r\n        \r\n        <p className=\"text-sm text-gray-500\">\r\n          {progress.completed} of {progress.total} items migrated\r\n          {progress.errors > 0 && ` (${progress.errors} errors)`}\r\n        </p>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  if (step === 'complete') {\r\n    const totalSuccess = results?.total.success || 0;\r\n    const totalErrors = results?.total.errors || 0;\r\n\r\n    return (\r\n      <Card className=\"p-6 max-w-2xl mx-auto\">\r\n        <h2 className=\"text-2xl font-bold mb-4\">Migration Complete!</h2>\r\n        \r\n        <div className=\"space-y-4 mb-6\">\r\n          <div className=\"bg-green-50 dark:bg-green-900/20 p-4 rounded-lg\">\r\n            <p className=\"font-semibold text-green-800 dark:text-green-200\">\r\n              Ô£ô Successfully migrated {totalSuccess} items\r\n            </p>\r\n            {totalErrors > 0 && (\r\n              <p className=\"text-red-600 dark:text-red-400 mt-2\">\r\n                {totalErrors} items failed to migrate\r\n              </p>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"text-sm space-y-2\">\r\n            <p>ÔÇó Characters: {results?.characters.success} migrated</p>\r\n            <p>ÔÇó World-building: {results?.worldBuilding.success} migrated</p>\r\n            <p>ÔÇó Version history: {results?.versioning.success} migrated</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg mb-6\">\r\n          <p className=\"font-semibold mb-2\">Clean up old data?</p>\r\n          <p className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n            Your data has been migrated to Turso. Would you like to delete the old local IndexedDB data?\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"flex gap-3\">\r\n          <Button onClick={handleClearOldData}>Yes, Clear Old Data</Button>\r\n          <Button onClick={onComplete} variant=\"secondary\">\r\n            Keep Old Data (Not Recommended)\r\n          </Button>\r\n        </div>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  return null;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\Navbar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\Navbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\PlannerControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ProjectDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ProjectStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ProjectStatsChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ai\\CostDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ai\\FallbackProviderEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ai\\ProviderSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ai\\ProviderStatusDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\ai\\__tests__\\FallbackProviderEditor.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\error-boundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\layout\\AppBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\layout\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\layout\\MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\components\\layout\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\contexts\\UserContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\AnalyticsContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\AnalyticsDashboard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\AnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\AnalyticsHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\AnalyticsSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\GoalsManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\GoalsProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\ProductivityChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\SessionTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\WritingStatsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\__tests__\\WritingStatsCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\hooks\\useAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\services\\__tests__\\analyticsService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\services\\analyticsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\analytics\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\CharacterStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\components\\__tests__\\CharacterCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\hooks\\__tests__\\useCharacters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\hooks\\useCharacterValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\hooks\\useCharacters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\services\\characterService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\characters\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\BookViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\ChapterEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\ChapterList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\CoverGenerator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\FocusMode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\ProjectOverview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\PublishPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\VoiceInputPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\__tests__\\FocusMode.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\components\\__tests__\\VoiceInputPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\hooks\\__tests__\\useGoapEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\hooks\\useEditorState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\hooks\\useGoapEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\services\\editorService.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'content' is assigned a value but never used.","line":219,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":219,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'summary' is assigned a value but never used.","line":219,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":219,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'content' is defined but never used.","line":285,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'summary' is defined but never used.","line":285,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\editor\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\components\\AchievementBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\components\\AchievementsList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\components\\GamificationDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\components\\GamificationPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\components\\StreakDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\hooks\\useGamification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\services\\gamificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\gamification\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\AIToolsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\ActionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\AgentConsole.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\BookViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\ChapterContentEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\ChapterSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\ImageGenerationDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\PlannerControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\ProjectOverviewPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\__tests__\\AgentConsole.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\__tests__\\BookViewer.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `BookViewer.test.tsx` to same directory as `../BookViewer` or consider making `../BookViewer` a package.","line":8,"column":24,"nodeType":"Literal","messageId":"noAllowed","endLine":8,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\hooks\\useGoapEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\hooks\\useGoapEngine.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\services\\imageGenerationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\generation\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\CharacterGraphView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\FeedbackCollector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\LoadingStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\PlotAnalyzer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\PlotEngineDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\PlotGenerator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\PlotHoleDetectorView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\StoryArcVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\__tests__\\PlotEngineDashboard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\components\\lazy-plot-engine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\__tests__\\useCharacterGraph.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\__tests__\\usePlotAnalysis.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\__tests__\\usePlotGeneration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\useCharacterGraph.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\usePlotAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\hooks\\usePlotGeneration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\characterGraphService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\modelSelection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\plotAnalysisService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\plotGenerationService.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\plotGenerationService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\plotHoleDetector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\plotStorageService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\rag-end-to-end.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\rag-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\__tests__\\ragIntegration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\characterGraphService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\plotAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\plotGenerationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\plotHoleDetector.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":189,"column":23,"nodeType":"NewExpression","endLine":189,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\services\\plotStorageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\plot-engine\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\AdvancedOptionsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\BasicFieldsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\IdeaInputSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\Navbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectStatsChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectWizard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectWizardFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectWizardHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\ProjectsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\__tests__\\ProjectDashboard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\project-wizard-constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\components\\useProjectWizard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\hooks\\__tests__\\useProjects.crud.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\hooks\\__tests__\\useProjects.errors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\hooks\\__tests__\\useProjects.filtering.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\hooks\\__tests__\\useProjects.initialization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\hooks\\useProjects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\__tests__\\projectService.creation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\__tests__\\projectService.modification.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\__tests__\\projectService.retrieval.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\services\\projectService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\projects\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\AlertsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\CoverGenerator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\DetailedFeedbackModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\FeedbackWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\MetricsOverview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PlatformCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PlatformStatusGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PublishPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PublishView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PublishingDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PublishingMetadataForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\PublishingSetup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\hooks\\usePublishingAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\services\\epubService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\services\\publishingAnalyticsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\publishing\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\components\\CacheStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\components\\SearchModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\components\\SearchResultItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\components\\SearchResults.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\__tests__\\query-cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\__tests__\\search-performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\__tests__\\search-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\batch-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\content-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\query-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\search-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\semantic-search\\services\\sync-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\components\\AISettingsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\components\\PWAInstallButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\components\\SettingsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\hooks\\__tests__\\useSettings.advanced.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\hooks\\__tests__\\useSettings.basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\hooks\\__tests__\\useSettings.edgeCases.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\hooks\\useSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\services\\settingsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\settings\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\components\\EventNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\components\\TimelineCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\components\\TimelineView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\stores\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\timeline\\stores\\timelineStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\components\\VersionComparison.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\components\\VersionHistory.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\components\\VersionHistory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\hooks\\useVersioning.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\hooks\\useVersioning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\services\\__tests__\\versioningService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\services\\versioningService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\versioning\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\components\\CultureManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\components\\LocationManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\components\\WorldBuildingDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\components\\WorldElementEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\hooks\\useWorldBuilding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\hooks\\useWorldBuildingValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\services\\worldBuildingDb.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mode' is assigned a value but never used.","line":26,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":86,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":118,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectId' is defined but never used.","line":138,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectId' is defined but never used.","line":143,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":143,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectId' is defined but never used.","line":148,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectId' is defined but never used.","line":153,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":47}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * World-Building Database Service\r\n * Handles persistence and retrieval of world-building data using Turso\r\n */\r\n\r\nimport type {\r\n  WorldBuildingProject,\r\n  Location,\r\n  Culture,\r\n  Timeline,\r\n  LoreEntry,\r\n  ResearchSource,\r\n  WorldMap,\r\n} from '@/features/world-building/types';\r\nimport { worldBuildingService as tursoWorldBuildingService } from '@/lib/database/services';\r\n\r\nclass WorldBuildingDatabase {\r\n  // Legacy properties removed - now fully using Turso\r\n  private db: IDBDatabase | null = null;\r\n\r\n  public async init(): Promise<void> {\r\n    // Delegate to Turso service\r\n    await tursoWorldBuildingService.init();\r\n  }\r\n\r\n  private getStore(storeName: string, mode: IDBTransactionMode = 'readonly'): IDBObjectStore {\r\n    // Legacy method - no longer used\r\n    throw new Error('IndexedDB operations are deprecated. Use Turso service instead.');\r\n  }\r\n\r\n  // ============================================================================\r\n  // World-Building Project Operations\r\n  // ============================================================================\r\n\r\n  public async saveWorldBuildingProject(project: WorldBuildingProject): Promise<void> {\r\n    const projects = await tursoWorldBuildingService.getProjectsByProjectId(project.projectId);\r\n    if (projects.length > 0) {\r\n      await tursoWorldBuildingService.updateProject(projects[0].id, project);\r\n    } else {\r\n      await tursoWorldBuildingService.createProject(project);\r\n    }\r\n  }\r\n\r\n  public async getWorldBuildingProject(projectId: string): Promise<WorldBuildingProject | null> {\r\n    const projects = await tursoWorldBuildingService.getProjectsByProjectId(projectId);\r\n    return projects.length > 0 ? projects[0] : null;\r\n  }\r\n\r\n  public async createWorldBuildingProject(projectId: string): Promise<WorldBuildingProject> {\r\n    const newProject: WorldBuildingProject = {\r\n      id: crypto.randomUUID(),\r\n      projectId,\r\n      locations: [],\r\n      cultures: [],\r\n      timelines: [],\r\n      lore: [],\r\n      researchSources: [],\r\n      maps: [],\r\n      settings: {\r\n        consistencyCheckEnabled: true,\r\n        autoLinkElements: true,\r\n      },\r\n      createdAt: Date.now(),\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    await tursoWorldBuildingService.createProject(newProject);\r\n    return newProject;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Location Operations\r\n  // ============================================================================\r\n\r\n  public async saveLocation(location: Location): Promise<void> {\r\n    const existing = await tursoWorldBuildingService.getLocationsByProjectId(location.worldBuildingProjectId);\r\n    const found = existing.find(l => l.id === location.id);\r\n    \r\n    if (found) {\r\n      await tursoWorldBuildingService.updateLocation(location.id, location);\r\n    } else {\r\n      await tursoWorldBuildingService.createLocation(location);\r\n    }\r\n  }\r\n\r\n  public async getLocation(id: string): Promise<Location | null> {\r\n    // Note: Turso service doesn't have getById for locations, so we'll need to fetch all and filter\r\n    // This is a limitation we should address in the Turso service layer\r\n    return null; // TODO: Implement getLocationById in Turso service\r\n  }\r\n\r\n  public async getLocationsByProject(projectId: string): Promise<Location[]> {\r\n    const wbProjects = await tursoWorldBuildingService.getProjectsByProjectId(projectId);\r\n    if (wbProjects.length === 0) return [];\r\n    \r\n    return tursoWorldBuildingService.getLocationsByProjectId(wbProjects[0].id);\r\n  }\r\n\r\n  public async deleteLocation(id: string): Promise<void> {\r\n    await tursoWorldBuildingService.deleteLocation(id);\r\n  }\r\n\r\n  // ============================================================================\r\n  // Culture Operations\r\n  // ============================================================================\r\n\r\n  public async saveCulture(culture: Culture): Promise<void> {\r\n    const existing = await tursoWorldBuildingService.getCulturesByProjectId(culture.worldBuildingProjectId);\r\n    const found = existing.find(c => c.id === culture.id);\r\n    \r\n    if (found) {\r\n      await tursoWorldBuildingService.updateCulture(culture.id, culture);\r\n    } else {\r\n      await tursoWorldBuildingService.createCulture(culture);\r\n    }\r\n  }\r\n\r\n  public async getCulture(id: string): Promise<Culture | null> {\r\n    // Note: Turso service doesn't have getById for cultures\r\n    return null; // TODO: Implement getCultureById in Turso service\r\n  }\r\n\r\n  public async getCulturesByProject(projectId: string): Promise<Culture[]> {\r\n    const wbProjects = await tursoWorldBuildingService.getProjectsByProjectId(projectId);\r\n    if (wbProjects.length === 0) return [];\r\n    \r\n    return tursoWorldBuildingService.getCulturesByProjectId(wbProjects[0].id);\r\n  }\r\n\r\n  public async deleteCulture(id: string): Promise<void> {\r\n    await tursoWorldBuildingService.deleteCulture(id);\r\n  }\r\n\r\n  // ============================================================================\r\n  // Simplified stubs for other operations to reduce boilerplate\r\n  // ============================================================================\r\n\r\n  public async getTimelinesByProject(projectId: string): Promise<Timeline[]> {\r\n    // TODO: Implement timeline operations in Turso service\r\n    return [];\r\n  }\r\n\r\n  public async getLoreByProject(projectId: string): Promise<LoreEntry[]> {\r\n    // TODO: Implement lore operations in Turso service\r\n    return [];\r\n  }\r\n\r\n  public async getResearchSourcesByProject(projectId: string): Promise<ResearchSource[]> {\r\n    // TODO: Implement research source operations in Turso service\r\n    return [];\r\n  }\r\n\r\n  public async getWorldMapsByProject(projectId: string): Promise<WorldMap[]> {\r\n    // TODO: Implement world map operations in Turso service\r\n    return [];\r\n  }\r\n}\r\n\r\nexport const worldBuildingDb = new WorldBuildingDatabase();","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\services\\worldBuildingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\world-building\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalCreateForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalEditForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalProgressBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalTargetsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalsImportExport.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalsList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalsPanelHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\GoalsPresetSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\InlineSuggestionTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\StyleAnalysisCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\WritingAnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\WritingAssistantPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\WritingAssistantSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\WritingGoalsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\__tests__\\WritingGoalsPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\components\\useGoalsPanelState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\__tests__\\useWritingAssistant.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\useInlineSuggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\useRealTimeAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\useWritingAssistant.ts","messages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Expected a non-Promise value to be spread in an object.","line":144,"column":67,"nodeType":"Identifier","messageId":"spread","endLine":144,"endColumn":75},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":177,"column":13,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":177,"endColumn":56,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[5768,5768],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[5768,5768],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":223,"column":13,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":228,"endColumn":15,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[7041,7041],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[7041,7041],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":373,"column":11,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":379,"endColumn":13,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[11743,11743],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[11743,11743],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":422,"column":11,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":427,"endColumn":13,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[13208,13208],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[13208,13208],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Writing Assistant Hook\n * Manages writing assistant state and provides analysis functionality\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nimport { type Character } from '@/features/characters/types';\nimport { writingAssistantDb } from '@/features/writing-assistant/services/writingAssistantDb';\nimport { writingAssistantService } from '@/features/writing-assistant/services/writingAssistantService';\nimport { DEFAULT_WRITING_ASSISTANT_CONFIG } from '@/features/writing-assistant/types';\nimport {\n  type WritingAssistantState,\n  type WritingAssistantActions,\n  type WritingAssistantConfig,\n  type ContentAnalysis,\n  type WritingSuggestion,\n  type WritingSuggestionCategory,\n  type WritingProgressMetrics,\n} from '@/features/writing-assistant/types';\nimport { logger } from '@/lib/logging/logger';\n\nimport {\n  groupSuggestionsByCategory,\n  calculateAnalysisStats,\n  calculateAcceptanceRate,\n  generateLearningInsights,\n} from './useWritingAssistant.utils';\n\ninterface UseWritingAssistantOptions {\n  autoAnalyze?: boolean;\n  analysisDelay?: number;\n  chapterId?: string;\n  projectId?: string;\n  characterContext?: Character[];\n  plotContext?: string;\n  enablePersistence?: boolean;\n  onContentChange?: (newContent: string, suggestionId: string) => void;\n}\n\ninterface UseWritingAssistantReturn extends WritingAssistantState, WritingAssistantActions {\n  suggestionsByCategory: Record<WritingSuggestionCategory | 'all', WritingSuggestion[]>;\n  filteredSuggestions: WritingSuggestion[];\n  analysisStats: {\n    totalSuggestions: number;\n    highPrioritySuggestions: number;\n    avgConfidence: number;\n    topCategories: { category: WritingSuggestionCategory; count: number }[];\n  };\n  isAnalyzing: boolean;\n  isAnalyzingLocal: boolean;\n  lastAnalyzedAt?: Date;\n  analysisError?: string;\n  getWritingAnalytics: (timeRange?: 'week' | 'month' | 'year') => {\n    progressMetrics: WritingProgressMetrics[];\n    improvementTrends: {\n      readabilityTrend: number;\n      engagementTrend: number;\n      productivityTrend: number;\n    };\n    suggestionInsights: {\n      mostHelpfulCategories: string[];\n      acceptanceRate: number;\n      commonPatterns: string[];\n    };\n  };\n  suggestionAcceptanceRate: number;\n  learningInsights: {\n    preferredCategories: string[];\n    improvementTrends: Record<string, number>;\n    writingHabits: {\n      analysisFrequency: string;\n      preferredAnalysisTime: string;\n      mostActiveCategories: string[];\n    };\n  };\n}\n\nexport function useWritingAssistant(\n  content = '',\n  options: UseWritingAssistantOptions = {},\n): UseWritingAssistantReturn {\n  const {\n    autoAnalyze = true,\n    chapterId = '',\n    projectId = '',\n    characterContext = [],\n    plotContext = '',\n    enablePersistence = true,\n    onContentChange,\n  } = options;\n\n  // Core state\n  const [state, setState] = useState<WritingAssistantState>({\n    isActive: false,\n    isAnalyzing: false,\n    suggestions: [],\n    config: DEFAULT_WRITING_ASSISTANT_CONFIG,\n    showSuggestions: true,\n    filterBy: 'all',\n    sortBy: 'severity',\n  });\n\n  const [isAnalyzingLocal, setIsAnalyzingLocal] = useState(false);\n  const [currentAnalysis, setCurrentAnalysis] = useState<ContentAnalysis | undefined>();\n  const [lastAnalyzedAt, setLastAnalyzedAt] = useState<Date>();\n  const [analysisError, setAnalysisError] = useState<string>();\n\n  // Refs\n  const lastContentRef = useRef<string>('');\n  const appliedSuggestions = useRef<Set<string>>(new Set());\n  const dismissedSuggestions = useRef<Set<string>>(new Set());\n  const suggestionInteractions = useRef<\n    Map<string, { action: 'applied' | 'dismissed' | 'viewed'; timestamp: Date }>\n  >(new Map());\n  const localAnalysisTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const aiAnalysisTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n\n  // Configuration management\n  useEffect(() => {\n    const loadConfiguration = () => {\n      try {\n        const localConfig = localStorage.getItem('novelist_writing_assistant_config');\n        const isActive = localStorage.getItem('novelist_writing_assistant_active') === 'true';\n\n        if (localConfig != null) {\n          const config = JSON.parse(localConfig) as Partial<WritingAssistantConfig>;\n          setState(prev => ({\n            ...prev,\n            config: { ...DEFAULT_WRITING_ASSISTANT_CONFIG, ...config },\n            isActive,\n          }));\n        } else {\n          setState(prev => ({ ...prev, isActive }));\n        }\n\n        // Background DB sync\n        if (enablePersistence) {\n          try {\n            const dbConfig = writingAssistantDb.loadPreferences();\n            if (dbConfig != null && localConfig == null) {\n              setState(prev => ({\n                ...prev,\n                config: { ...DEFAULT_WRITING_ASSISTANT_CONFIG, ...dbConfig },\n              }));\n              localStorage.setItem('novelist_writing_assistant_config', JSON.stringify(dbConfig));\n            }\n          } catch (error) {\n            logger.warn('Failed to load preferences from database', {\n              component: 'useWritingAssistant',\n              error,\n            });\n          }\n        }\n      } catch (error) {\n        logger.error('Failed to load writing assistant config', {\n          component: 'useWritingAssistant',\n          error,\n        });\n        setState(prev => ({\n          ...prev,\n          config: DEFAULT_WRITING_ASSISTANT_CONFIG,\n          isActive: false,\n        }));\n      }\n    };\n\n    void loadConfiguration();\n  }, [enablePersistence]);\n\n  const saveConfig = useCallback(\n    (config: WritingAssistantConfig) => {\n      try {\n        localStorage.setItem('novelist_writing_assistant_config', JSON.stringify(config));\n        if (enablePersistence) {\n          try {\n            writingAssistantDb.syncPreferences(config);\n          } catch (error) {\n            logger.warn('Failed to sync preferences to database', {\n              component: 'useWritingAssistant',\n              error,\n            });\n          }\n        }\n      } catch (error) {\n        logger.error('Failed to save writing assistant config', {\n          component: 'useWritingAssistant',\n          error,\n        });\n      }\n    },\n    [enablePersistence],\n  );\n\n  // Core analysis functions\n  const analyzeContent = useCallback(\n    async (contentToAnalyze: string = content) => {\n      if (!contentToAnalyze.trim() || !state.isActive) return;\n\n      setState(prev => ({ ...prev, isAnalyzing: true }));\n      setAnalysisError(undefined);\n\n      try {\n        const analysis = await writingAssistantService.analyzeContent(\n          contentToAnalyze,\n          chapterId,\n          state.config,\n          characterContext,\n          plotContext,\n        );\n\n        setCurrentAnalysis(analysis);\n        setState(prev => ({\n          ...prev,\n          suggestions: analysis.suggestions,\n          isAnalyzing: false,\n        }));\n        setLastAnalyzedAt(new Date());\n\n        // Background persistence\n        if (enablePersistence && projectId) {\n          try {\n            writingAssistantDb.saveAnalysisHistory(\n              analysis,\n              projectId,\n              appliedSuggestions.current.size,\n              dismissedSuggestions.current.size,\n            );\n          } catch (error) {\n            logger.warn('Failed to save analysis history', {\n              component: 'useWritingAssistant',\n              error,\n            });\n          }\n        }\n\n        // Track interactions\n        analysis.suggestions.forEach(suggestion => {\n          suggestionInteractions.current.set(suggestion.id, {\n            action: 'viewed',\n            timestamp: new Date(),\n          });\n        });\n      } catch (error) {\n        logger.error('Analysis failed', { component: 'useWritingAssistant', error });\n        setAnalysisError(error instanceof Error ? error.message : 'Analysis failed');\n        setState(prev => ({ ...prev, isAnalyzing: false }));\n      }\n    },\n    [\n      content,\n      chapterId,\n      state.isActive,\n      state.config,\n      characterContext,\n      plotContext,\n      enablePersistence,\n      projectId,\n    ],\n  );\n\n  const analyzeLocal = useCallback(\n    (contentToAnalyze: string = content) => {\n      if (!contentToAnalyze.trim() || !state.isActive) return;\n\n      setIsAnalyzingLocal(true);\n      try {\n        const localMetrics = writingAssistantService.analyzeLocalMetrics(\n          contentToAnalyze,\n          state.config,\n        );\n        setCurrentAnalysis(\n          prev =>\n            ({\n              ...prev,\n              chapterId,\n              content: contentToAnalyze,\n              timestamp: new Date(),\n              ...localMetrics,\n              suggestions: prev?.suggestions || [],\n              plotHoles: prev?.plotHoles || [],\n              characterIssues: prev?.characterIssues || [],\n              dialogueAnalysis: prev?.dialogueAnalysis || {\n                totalDialogue: 0,\n                dialoguePercentage: 0,\n                speakerVariety: 0,\n                averageDialogueLength: 0,\n                issues: [],\n                voiceConsistency: [],\n                tagAnalysis: { totalTags: 0, varietyScore: 0, overusedTags: [], suggestions: [] },\n              },\n            }) as ContentAnalysis,\n        );\n      } finally {\n        setIsAnalyzingLocal(false);\n      }\n    },\n    [content, state.isActive, state.config, chapterId],\n  );\n\n  const debouncedAnalyze = useCallback(\n    (contentToAnalyze: string) => {\n      // Local analysis\n      if (localAnalysisTimeoutRef.current) {\n        clearTimeout(localAnalysisTimeoutRef.current);\n      }\n      localAnalysisTimeoutRef.current = setTimeout(() => {\n        if (state.config.enableRealTimeAnalysis) {\n          analyzeLocal(contentToAnalyze);\n        }\n      }, 300);\n\n      // AI analysis\n      if (aiAnalysisTimeoutRef.current) {\n        clearTimeout(aiAnalysisTimeoutRef.current);\n      }\n      aiAnalysisTimeoutRef.current = setTimeout(\n        () => {\n          if (contentToAnalyze !== lastContentRef.current && state.config.enableRealTimeAnalysis) {\n            void analyzeContent(contentToAnalyze);\n            lastContentRef.current = contentToAnalyze;\n          }\n        },\n        Math.max(state.config.analysisDelay, 2000),\n      );\n    },\n    [analyzeLocal, analyzeContent, state.config.enableRealTimeAnalysis, state.config.analysisDelay],\n  );\n\n  // Auto-analysis effect\n  useEffect(() => {\n    if (autoAnalyze && content && state.isActive && content !== lastContentRef.current) {\n      debouncedAnalyze(content);\n    }\n    return () => {\n      if (localAnalysisTimeoutRef.current) {\n        clearTimeout(localAnalysisTimeoutRef.current);\n      }\n      if (aiAnalysisTimeoutRef.current) {\n        clearTimeout(aiAnalysisTimeoutRef.current);\n      }\n    };\n  }, [content, autoAnalyze, state.isActive, debouncedAnalyze]);\n\n  // Action functions\n  const toggleAssistant = useCallback(() => {\n    setState(prev => {\n      const newIsActive = !prev.isActive;\n      localStorage.setItem('novelist_writing_assistant_active', newIsActive.toString());\n      return { ...prev, isActive: newIsActive };\n    });\n  }, []);\n\n  const applySuggestion = useCallback(\n    (suggestionId: string) => {\n      const suggestion = state.suggestions.find(s => s.id === suggestionId);\n      if (!suggestion) return;\n\n      appliedSuggestions.current.add(suggestionId);\n      setState(prev => ({\n        ...prev,\n        suggestions: prev.suggestions.filter(s => s.id !== suggestionId),\n      }));\n\n      suggestionInteractions.current.set(suggestionId, {\n        action: 'applied',\n        timestamp: new Date(),\n      });\n\n      // Background persistence\n      if (enablePersistence && projectId && chapterId) {\n        try {\n          writingAssistantDb.recordSuggestionFeedback(\n            suggestion,\n            'accepted',\n            chapterId,\n            projectId,\n            suggestion.suggestedText,\n          );\n        } catch (error) {\n          logger.warn('Failed to record suggestion feedback', {\n            component: 'useWritingAssistant',\n            error,\n            suggestionId,\n          });\n        }\n      }\n\n      // Apply text change\n      if (\n        onContentChange &&\n        suggestion.originalText &&\n        suggestion.suggestedText &&\n        suggestion.originalText !== '' &&\n        suggestion.suggestedText !== ''\n      ) {\n        const newContent = content.replace(suggestion.originalText, suggestion.suggestedText);\n        onContentChange(newContent, suggestionId);\n      }\n    },\n    [state.suggestions, enablePersistence, projectId, chapterId, onContentChange, content],\n  );\n\n  const dismissSuggestion = useCallback(\n    (suggestionId: string) => {\n      const suggestion = state.suggestions.find(s => s.id === suggestionId);\n      if (!suggestion) return;\n\n      dismissedSuggestions.current.add(suggestionId);\n      setState(prev => ({\n        ...prev,\n        suggestions: prev.suggestions.filter(s => s.id !== suggestionId),\n      }));\n\n      suggestionInteractions.current.set(suggestionId, {\n        action: 'dismissed',\n        timestamp: new Date(),\n      });\n\n      if (enablePersistence && projectId && chapterId) {\n        try {\n          writingAssistantDb.recordSuggestionFeedback(\n            suggestion,\n            'dismissed',\n            chapterId,\n            projectId,\n          );\n        } catch (error) {\n          logger.warn('Failed to record suggestion feedback', {\n            component: 'useWritingAssistant',\n            error,\n            suggestionId,\n          });\n        }\n      }\n    },\n    [state.suggestions, enablePersistence, projectId, chapterId],\n  );\n\n  const updateConfig = useCallback(\n    (configUpdate: Partial<WritingAssistantConfig>) => {\n      setState(prev => {\n        const newConfig = { ...prev.config, ...configUpdate };\n        saveConfig(newConfig);\n        return { ...prev, config: newConfig };\n      });\n    },\n    [saveConfig],\n  );\n\n  const selectSuggestion = useCallback((suggestionId: string) => {\n    setState(prev => ({ ...prev, selectedSuggestion: suggestionId }));\n  }, []);\n\n  const toggleSuggestions = useCallback(() => {\n    setState(prev => ({ ...prev, showSuggestions: !prev.showSuggestions }));\n  }, []);\n\n  const filterSuggestions = useCallback((category: WritingSuggestionCategory | 'all') => {\n    setState(prev => ({ ...prev, filterBy: category }));\n  }, []);\n\n  const sortSuggestions = useCallback((sortBy: WritingAssistantState['sortBy']) => {\n    setState(prev => ({ ...prev, sortBy }));\n  }, []);\n\n  const getWritingAnalytics = useCallback(\n    (timeRange: 'week' | 'month' | 'year' = 'month') => {\n      if (!enablePersistence || !projectId) {\n        return {\n          progressMetrics: [],\n          improvementTrends: { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 },\n          suggestionInsights: { mostHelpfulCategories: [], acceptanceRate: 0, commonPatterns: [] },\n        };\n      }\n\n      try {\n        return writingAssistantDb.getWritingAnalytics(projectId, timeRange);\n      } catch (error) {\n        logger.error('Failed to get writing analytics', {\n          component: 'useWritingAssistant',\n          error,\n          projectId,\n          timeRange,\n        });\n        return {\n          progressMetrics: [],\n          improvementTrends: { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 },\n          suggestionInsights: { mostHelpfulCategories: [], acceptanceRate: 0, commonPatterns: [] },\n        };\n      }\n    },\n    [enablePersistence, projectId],\n  );\n\n  // Computed values\n  const suggestionsByCategory = groupSuggestionsByCategory(state.suggestions);\n  const filteredSuggestions =\n    state.filterBy === 'all' ? state.suggestions : (suggestionsByCategory[state.filterBy] ?? []);\n  const sortedSuggestions = filteredSuggestions.sort((a, b) => {\n    switch (state.sortBy) {\n      case 'severity':\n        const severityOrder = { error: 4, warning: 3, suggestion: 2, info: 1 };\n        return severityOrder[b.severity] - severityOrder[a.severity];\n      case 'type':\n        return a.type.localeCompare(b.type);\n      case 'position':\n        return a.position.start - b.position.start;\n      case 'confidence':\n        return b.confidence - a.confidence;\n      default:\n        return 0;\n    }\n  });\n  const analysisStats = calculateAnalysisStats(state.suggestions);\n  const suggestionAcceptanceRate = calculateAcceptanceRate(\n    appliedSuggestions.current,\n    dismissedSuggestions.current,\n  );\n  const learningInsights = generateLearningInsights(\n    state.suggestions,\n    suggestionInteractions.current,\n    currentAnalysis,\n    analysisStats,\n  );\n\n  return {\n    // State\n    ...state,\n    currentAnalysis,\n\n    // Actions\n    toggleAssistant,\n    analyzeContent,\n    applySuggestion,\n    dismissSuggestion,\n    updateConfig,\n    selectSuggestion,\n    toggleSuggestions,\n    filterSuggestions,\n    sortSuggestions,\n\n    // Computed properties\n    suggestionsByCategory,\n    filteredSuggestions: sortedSuggestions,\n    analysisStats,\n\n    // Status\n    lastAnalyzedAt,\n    analysisError,\n    isAnalyzingLocal,\n\n    // Analytics and insights\n    getWritingAnalytics,\n    suggestionAcceptanceRate,\n    learningInsights,\n  };\n}\n\nexport default useWritingAssistant;\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\useWritingAssistant.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\hooks\\useWritingGoals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\__tests__\\goalsService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\__tests__\\grammarSuggestionService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\__tests__\\styleAnalysisService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\__tests__\\writingAssistantDb.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\__tests__\\writingAssistantService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\goalsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\grammarSuggestionService.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":298,"column":25,"nodeType":"NewExpression","endLine":298,"endColumn":64,"suppressions":[{"kind":"directive","justification":"misspelled comes from controlled hardcoded dictionary"}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":460,"column":25,"nodeType":"NewExpression","endLine":460,"endColumn":65,"suppressions":[{"kind":"directive","justification":"wordyPhrase comes from controlled WORDY_PHRASES constant"}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":499,"column":23,"nodeType":"NewExpression","endLine":499,"endColumn":60,"suppressions":[{"kind":"directive","justification":"weakWord comes from controlled WEAK_WORDS constant"}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":552,"column":23,"nodeType":"NewExpression","endLine":552,"endColumn":65,"suppressions":[{"kind":"directive","justification":"escapedPhrase is sanitized from controlled redundantPhrases array"}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":642,"column":37,"nodeType":"NewExpression","endLine":642,"endColumn":72,"suppressions":[{"kind":"directive","justification":"phrase comes from controlled WORDY_PHRASES constant"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\realTimeAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\styleAnalysisService.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":268,"column":23,"nodeType":"NewExpression","endLine":268,"endColumn":50,"suppressions":[{"kind":"directive","justification":"indicator comes from controlled toneIndicators constant"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\writing-analyzers.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":69,"column":49,"nodeType":"NewExpression","endLine":69,"endColumn":70,"suppressions":[{"kind":"directive","justification":"word comes from controlled actionWords array"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\writing-style-analyzers.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":36,"column":44,"nodeType":"NewExpression","endLine":36,"endColumn":81,"suppressions":[{"kind":"directive","justification":"indicator comes from controlled passiveIndicators array"}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":257,"column":44,"nodeType":"NewExpression","endLine":257,"endColumn":82,"suppressions":[{"kind":"directive","justification":"transition comes from controlled transitions array"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\writingAssistantDb.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'generateSecureId' is defined but never used.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'acceptedCount' is assigned a value but never used.","line":136,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":136,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dismissedCount' is assigned a value but never used.","line":137,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'appliedText' is defined but never used.","line":174,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":16}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Writing Assistant Database Service\r\n * Now fully using Turso for persistent analytics and preferences\r\n */\r\n\r\nimport {\r\n  type ContentAnalysis,\r\n  type WritingAssistantConfig,\r\n  type WritingSuggestion,\r\n} from '@/features/writing-assistant/types';\r\nimport { writingAssistantService as tursoWritingAssistantService } from '@/lib/database/services';\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\n\r\n// Database schema types for Writing Assistant\r\nexport interface AnalysisHistory {\r\n  id: string;\r\n  userId: string;\r\n  chapterId: string;\r\n  projectId: string;\r\n  readabilityScore: number;\r\n  engagementScore: number;\r\n  sentimentScore: number;\r\n  paceScore: number;\r\n  suggestionCount: number;\r\n  suggestionCategories: string[]; // JSON array\r\n  acceptedSuggestions: number;\r\n  dismissedSuggestions: number;\r\n  analysisDepth: 'basic' | 'standard' | 'comprehensive';\r\n  contentWordCount: number;\r\n  timestamp: Date;\r\n  createdAt: Date;\r\n}\r\n\r\nexport interface UserWritingPreferences {\r\n  id: string;\r\n  userId: string;\r\n  preferences: WritingAssistantConfig;\r\n  lastSyncedAt: Date;\r\n  deviceId: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface SuggestionFeedback {\r\n  id: string;\r\n  userId: string;\r\n  suggestionType: string;\r\n  suggestionCategory: string;\r\n  action: 'accepted' | 'dismissed' | 'ignored';\r\n  originalText?: string;\r\n  appliedText?: string;\r\n  confidence: number;\r\n  contextWordCount: number;\r\n  chapterId: string;\r\n  projectId: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface WritingProgressMetrics {\r\n  id: string;\r\n  userId: string;\r\n  projectId: string;\r\n  date: string; // YYYY-MM-DD\r\n  wordsWritten: number;\r\n  timeSpent: number; // minutes\r\n  suggestionsReceived: number;\r\n  suggestionsAccepted: number;\r\n  averageReadability: number;\r\n  averageEngagement: number;\r\n  chaptersWorkedOn: number;\r\n  createdAt: Date;\r\n}\r\n\r\nclass WritingAssistantDb {\r\n  private static instance: WritingAssistantDb;\r\n  private userId: string | null = null;\r\n  private readonly deviceId: string;\r\n\r\n  private constructor() {\r\n    this.deviceId = this.getOrCreateDeviceId();\r\n    this.initializeUserId();\r\n  }\r\n\r\n  public static getInstance(): WritingAssistantDb {\r\n    WritingAssistantDb.instance ??= new WritingAssistantDb();\r\n    return WritingAssistantDb.instance;\r\n  }\r\n\r\n  private getOrCreateDeviceId(): string {\r\n    try {\r\n      let deviceId = localStorage.getItem('novelist_device_id');\r\n      if (deviceId == null) {\r\n        const randomSuffix = window.crypto\r\n          .getRandomValues(new Uint32Array(2))\r\n          .reduce((acc, val) => acc + val.toString(36), '');\r\n        deviceId = `device_${Date.now()}_${randomSuffix}`;\r\n        localStorage.setItem('novelist_device_id', deviceId);\r\n      }\r\n      return deviceId;\r\n    } catch {\r\n      logger.warn('LocalStorage access denied, using temporary device ID', {\r\n        component: 'WritingAssistantDb',\r\n      });\r\n      return `temp_device_${Date.now()}`;\r\n    }\r\n  }\r\n\r\n  private initializeUserId(): void {\r\n    // In a real app, this would come from authentication\r\n    // For now, create a persistent anonymous user ID\r\n    try {\r\n      let userId = localStorage.getItem('novelist_user_id');\r\n      if (userId == null) {\r\n        const randomSuffix = window.crypto\r\n          .getRandomValues(new Uint32Array(2))\r\n          .reduce((acc, val) => acc + val.toString(36), '');\r\n        userId = `user_${Date.now()}_${randomSuffix}`;\r\n        localStorage.setItem('novelist_user_id', userId);\r\n      }\r\n      this.userId = userId;\r\n    } catch {\r\n      logger.warn('LocalStorage access denied, using temporary user ID', {\r\n        component: 'WritingAssistantDb',\r\n      });\r\n      this.userId = `temp_user_${Date.now()}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save analysis results to database for historical tracking\r\n   */\r\n  public async saveAnalysisHistory(\r\n    analysis: ContentAnalysis,\r\n    projectId: string,\r\n    acceptedCount = 0,\r\n    dismissedCount = 0,\r\n  ): Promise<void> {\r\n    if (this.userId == null) return;\r\n\r\n    try {\r\n      await tursoWritingAssistantService.saveAnalysis(\r\n        analysis.chapterId,\r\n        projectId,\r\n        analysis.readabilityScore,\r\n        analysis.engagementScore,\r\n        analysis.sentimentScore,\r\n        analysis.paceScore,\r\n        analysis.suggestions.length,\r\n        [...new Set(analysis.suggestions.map(s => s.category))],\r\n        'standard',\r\n        this.countWords(analysis.content),\r\n      );\r\n\r\n      // Update daily progress metrics\r\n      this.updateDailyProgress();\r\n    } catch (error) {\r\n      logger.error('Failed to save analysis history', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n      });\r\n      // Fail gracefully - don't break the user experience\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record user feedback on suggestions for machine learning\r\n   */\r\n  public async recordSuggestionFeedback(\r\n    suggestion: WritingSuggestion,\r\n    action: 'accepted' | 'dismissed' | 'ignored',\r\n    chapterId: string,\r\n    projectId: string,\r\n    appliedText?: string,\r\n  ): Promise<void> {\r\n    if (this.userId == null) return;\r\n\r\n    try {\r\n      await tursoWritingAssistantService.recordSuggestionFeedback(\r\n        suggestion.type,\r\n        suggestion.category,\r\n        action,\r\n        suggestion.originalText,\r\n        chapterId,\r\n        projectId,\r\n      );\r\n    } catch (error) {\r\n      logger.error('Failed to record suggestion feedback', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sync user preferences across devices (optional)\r\n   */\r\n  public async syncPreferences(config: WritingAssistantConfig): Promise<void> {\r\n    if (this.userId == null) return;\r\n\r\n    try {\r\n      await tursoWritingAssistantService.savePreferences(config);\r\n    } catch (error) {\r\n      logger.error('Failed to sync preferences', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load preferences from database (fallback if localStorage is empty)\r\n   */\r\n  public async loadPreferences(): Promise<WritingAssistantConfig | null> {\r\n    if (this.userId == null) return null;\r\n\r\n    try {\r\n      const preferences = await tursoWritingAssistantService.getPreferences();\r\n      return preferences as WritingAssistantConfig | null;\r\n    } catch (error) {\r\n      logger.error('Failed to load preferences', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get writing analytics for progress tracking\r\n   */\r\n  public getWritingAnalytics(\r\n    projectId: string,\r\n    timeRange: 'week' | 'month' | 'year' = 'month',\r\n  ): {\r\n    progressMetrics: WritingProgressMetrics[];\r\n    improvementTrends: {\r\n      readabilityTrend: number;\r\n      engagementTrend: number;\r\n      productivityTrend: number;\r\n    };\r\n    suggestionInsights: {\r\n      mostHelpfulCategories: string[];\r\n      acceptanceRate: number;\r\n      commonPatterns: string[];\r\n    };\r\n  } {\r\n    if (this.userId == null) {\r\n      return {\r\n        progressMetrics: [],\r\n        improvementTrends: { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 },\r\n        suggestionInsights: { mostHelpfulCategories: [], acceptanceRate: 0, commonPatterns: [] },\r\n      };\r\n    }\r\n\r\n    try {\r\n      const progressMetrics = this.getProgressMetrics(this.userId, projectId, timeRange);\r\n      const analysisHistory = this.getAnalysisHistory(this.userId, projectId, timeRange);\r\n      const suggestionFeedback = this.getSuggestionFeedback(this.userId, projectId, timeRange);\r\n\r\n      // Calculate trends\r\n      const improvementTrends = this.calculateImprovementTrends(analysisHistory);\r\n      const suggestionInsights = this.analyzeSuggestionPatterns(suggestionFeedback);\r\n\r\n      return {\r\n        progressMetrics,\r\n        improvementTrends,\r\n        suggestionInsights,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to get writing analytics', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n        projectId,\r\n      });\r\n      return {\r\n        progressMetrics: [],\r\n        improvementTrends: { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 },\r\n        suggestionInsights: { mostHelpfulCategories: [], acceptanceRate: 0, commonPatterns: [] },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old data (privacy-friendly)\r\n   */\r\n  public cleanupOldData(retentionDays = 365): void {\r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\r\n\r\n    try {\r\n      this.deleteOldAnalysisHistory(cutoffDate);\r\n      this.deleteOldSuggestionFeedback(cutoffDate);\r\n      this.deleteOldProgressMetrics(cutoffDate);\r\n    } catch (error) {\r\n      logger.error('Failed to cleanup old data', {\r\n        component: 'WritingAssistantDb',\r\n        error,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Private helper methods\r\n  private countWords(text: string): number {\r\n    return text\r\n      .trim()\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0).length;\r\n  }\r\n\r\n  private calculateImprovementTrends(history: AnalysisHistory[]): {\r\n    readabilityTrend: number;\r\n    engagementTrend: number;\r\n    productivityTrend: number;\r\n  } {\r\n    if (history.length < 2) {\r\n      return { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 };\r\n    }\r\n\r\n    const sorted = history.sort(\r\n      (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime(),\r\n    );\r\n    const first = sorted[0];\r\n    const last = sorted[sorted.length - 1];\r\n\r\n    if (!first || !last) {\r\n      return { readabilityTrend: 0, engagementTrend: 0, productivityTrend: 0 };\r\n    }\r\n\r\n    return {\r\n      readabilityTrend: last.readabilityScore - first.readabilityScore,\r\n      engagementTrend: last.engagementScore - first.engagementScore,\r\n      productivityTrend: last.contentWordCount / sorted.length - first.contentWordCount,\r\n    };\r\n  }\r\n\r\n  private analyzeSuggestionPatterns(feedback: SuggestionFeedback[]): {\r\n    mostHelpfulCategories: string[];\r\n    acceptanceRate: number;\r\n    commonPatterns: string[];\r\n  } {\r\n    if (feedback.length === 0) {\r\n      return { mostHelpfulCategories: [], acceptanceRate: 0, commonPatterns: [] };\r\n    }\r\n\r\n    const accepted = feedback.filter(f => f.action === 'accepted');\r\n    const acceptanceRate = accepted.length / feedback.length;\r\n\r\n    // Find most helpful categories\r\n    const categoryStats = feedback.reduce<Record<string, number>>((acc, f) => {\r\n      if (f.action === 'accepted') {\r\n        acc[f.suggestionCategory] = (acc[f.suggestionCategory] ?? 0) + 1;\r\n      }\r\n      return acc;\r\n    }, {});\r\n\r\n    const mostHelpfulCategories = Object.entries(categoryStats)\r\n      .sort(([, a], [, b]) => b - a)\r\n      .slice(0, 3)\r\n      .map(([category]) => category);\r\n\r\n    return {\r\n      mostHelpfulCategories,\r\n      acceptanceRate,\r\n      commonPatterns: [], // Would implement pattern detection\r\n    };\r\n  }\r\n\r\n  private updateDailyProgress(): void {\r\n    // This would be actual database operations\r\n    // For now, we'll implement mock versions\r\n  }\r\n\r\n  // Mock database operations (would be replaced with actual Turso queries)\r\n  private insertAnalysisHistory(record: Omit<AnalysisHistory, 'createdAt'>): void {\r\n    // await db.insert(analysisHistoryTable).values(record);\r\n    logger.info('Saving analysis history:', { analysisId: record.id });\r\n  }\r\n\r\n  private insertSuggestionFeedback(record: Omit<SuggestionFeedback, 'id'>): void {\r\n    // await db.insert(suggestionFeedbackTable).values(record);\r\n    logger.info('Recording suggestion feedback:', {\r\n      suggestionType: record.suggestionType,\r\n      action: record.action,\r\n    });\r\n  }\r\n\r\n  private upsertUserPreferences(\r\n    record: Omit<UserWritingPreferences, 'createdAt' | 'updatedAt'>,\r\n  ): void {\r\n    // await db.insert(userPreferencesTable).values(record).onConflictDoUpdate(...);\r\n    logger.info('Syncing preferences for user:', { userId: record.userId });\r\n  }\r\n\r\n  private getUserPreferences(userId: string): UserWritingPreferences | null {\r\n    // return await db.select().from(userPreferencesTable).where(eq(userPreferencesTable.userId, userId));\r\n    logger.info('Loading preferences for user:', { userId });\r\n    return null;\r\n  }\r\n\r\n  private getProgressMetrics(\r\n    userId: string,\r\n    projectId: string,\r\n    timeRange: string,\r\n  ): WritingProgressMetrics[] {\r\n    logger.info('Loading progress metrics:', { userId, projectId, timeRange });\r\n    return [];\r\n  }\r\n\r\n  private getAnalysisHistory(\r\n    userId: string,\r\n    projectId: string,\r\n    timeRange: string,\r\n  ): AnalysisHistory[] {\r\n    logger.info('Loading analysis history:', { userId, projectId, timeRange });\r\n    return [];\r\n  }\r\n\r\n  private getSuggestionFeedback(\r\n    userId: string,\r\n    projectId: string,\r\n    timeRange: string,\r\n  ): SuggestionFeedback[] {\r\n    logger.info('Loading suggestion feedback:', { userId, projectId, timeRange });\r\n    return [];\r\n  }\r\n\r\n  private deleteOldAnalysisHistory(cutoffDate: Date): void {\r\n    logger.info('Cleaning up analysis history older than:', {\r\n      cutoffDate: cutoffDate.toISOString(),\r\n    });\r\n  }\r\n\r\n  private deleteOldSuggestionFeedback(cutoffDate: Date): void {\r\n    logger.info('Cleaning up suggestion feedback older than:', {\r\n      cutoffDate: cutoffDate.toISOString(),\r\n    });\r\n  }\r\n\r\n  private deleteOldProgressMetrics(cutoffDate: Date): void {\r\n    logger.info('Cleaning up progress metrics older than:', {\r\n      cutoffDate: cutoffDate.toISOString(),\r\n    });\r\n  }\r\n}\r\n\r\nexport const writingAssistantDb = WritingAssistantDb.getInstance();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\services\\writingAssistantService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\types\\grammarSuggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\types\\realTimeFeedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\types\\styleAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\features\\writing-assistant\\types\\writingGoals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\__tests__\\db.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-operations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai-sdk-logger-patch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\ai.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\__tests__\\analytics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\experiments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\feature-tracking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\feedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\analytics\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\api-gateway\\__tests__\\client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\api-gateway\\__tests__\\middleware.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\api-gateway\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\api-gateway\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\api-gateway\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\character-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\__tests__\\cache.stats.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\ai-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\cache.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-possible-timing-attacks","severity":1,"message":"Potential timing attack, right side: true","line":70,"column":3,"nodeType":"IfStatement","endLine":81,"endColumn":4,"suppressions":[{"kind":"directive","justification":"hash comparison is not security-sensitive, only cache validation"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\contextCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\contextExtractor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\contextExtractor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\contextInjector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\contextInjector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\extractor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\formatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\token-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\context\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\drizzle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\migration-utility.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1657,1660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1657,1660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":112,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":122,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":167,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":167,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":185,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6442,6445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6442,6445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * IndexedDB to Turso Migration Utility\r\n * Helps users migrate their data from IndexedDB to Turso cloud database\r\n */\r\nimport { characterService } from '@/lib/database/services/character-service';\r\nimport { versioningService } from '@/lib/database/services/versioning-service';\r\nimport { worldBuildingService } from '@/lib/database/services/world-building-service';\r\nimport { logger } from '@/lib/logging/logger';\r\n// Publishing and writing assistant services imported but not yet used in migration\r\n// import { publishingService } from '@/lib/database/services/publishing-service';\r\n// import { writingAssistantService } from '@/lib/database/services/writing-assistant-service';\r\n\r\nexport interface MigrationProgress {\r\n  total: number;\r\n  completed: number;\r\n  errors: number;\r\n  currentTask: string;\r\n}\r\n\r\nexport type MigrationCallback = (progress: MigrationProgress) => void;\r\n\r\n/**\r\n * Migrate characters from IndexedDB to Turso\r\n */\r\nasync function migrateCharacters(\r\n  projectId: string,\r\n  onProgress?: MigrationCallback,\r\n): Promise<{ success: number; errors: number }> {\r\n  const dbName = 'novelist-characters';\r\n  let success = 0;\r\n  let errors = 0;\r\n\r\n  try {\r\n    const db = await new Promise<IDBDatabase>((resolve, reject) => {\r\n      const request = indexedDB.open(dbName);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new Error('Failed to open IndexedDB'));\r\n    });\r\n\r\n    const transaction = db.transaction(['characters'], 'readonly');\r\n    const store = transaction.objectStore('characters');\r\n    const index = store.index('projectId');\r\n    const characters = await new Promise<any[]>((resolve, reject) => {\r\n      const request = index.getAll(projectId);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new Error('Failed to get characters'));\r\n    });\r\n\r\n    const total = characters.length;\r\n    onProgress?.({ total, completed: 0, errors: 0, currentTask: 'Migrating characters' });\r\n\r\n    for (let i = 0; i < characters.length; i++) {\r\n      const char = characters[i];\r\n      try {\r\n        await characterService.createCharacter(char);\r\n        success++;\r\n      } catch (error) {\r\n        logger.error('Failed to migrate character', { component: 'Migration' }, error as Error);\r\n        errors++;\r\n      }\r\n      onProgress?.({ total, completed: i + 1, errors, currentTask: 'Migrating characters' });\r\n    }\r\n\r\n    db.close();\r\n  } catch (error) {\r\n    logger.error('Failed to migrate characters', { component: 'Migration' }, error as Error);\r\n  }\r\n\r\n  return { success, errors };\r\n}\r\n\r\n/**\r\n * Migrate world-building data from IndexedDB to Turso\r\n */\r\nasync function migrateWorldBuilding(\r\n  projectId: string,\r\n  onProgress?: MigrationCallback,\r\n): Promise<{ success: number; errors: number }> {\r\n  const dbName = 'novelist-world-building';\r\n  let success = 0;\r\n  let errors = 0;\r\n\r\n  try {\r\n    const db = await new Promise<IDBDatabase>((resolve, reject) => {\r\n      const request = indexedDB.open(dbName);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new Error('Failed to open IndexedDB'));\r\n    });\r\n\r\n    // Migrate world-building projects\r\n    const wbProjects = await getAllFromStore(db, 'projects');\r\n    onProgress?.({ total: wbProjects.length, completed: 0, errors: 0, currentTask: 'Migrating world-building data' });\r\n\r\n    for (const project of wbProjects) {\r\n      if (project.projectId === projectId) {\r\n        try {\r\n          await worldBuildingService.createProject(project);\r\n          success++;\r\n        } catch (error) {\r\n          logger.error('Failed to migrate world-building project', { component: 'Migration' }, error as Error);\r\n          errors++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Migrate locations, cultures, timelines, lore, sources, maps\r\n    const locations = await getAllFromStore(db, 'locations');\r\n    for (const location of locations) {\r\n      try {\r\n        await worldBuildingService.createLocation(location);\r\n        success++;\r\n      } catch (error) {\r\n        errors++;\r\n      }\r\n    }\r\n\r\n    const cultures = await getAllFromStore(db, 'cultures');\r\n    for (const culture of cultures) {\r\n      try {\r\n        await worldBuildingService.createCulture(culture);\r\n        success++;\r\n      } catch (error) {\r\n        errors++;\r\n      }\r\n    }\r\n\r\n    db.close();\r\n  } catch (error) {\r\n    logger.error('Failed to migrate world-building', { component: 'Migration' }, error as Error);\r\n  }\r\n\r\n  return { success, errors };\r\n}\r\n\r\n/**\r\n * Migrate versioning data from IndexedDB to Turso\r\n */\r\nasync function migrateVersioning(\r\n  projectId: string,\r\n  onProgress?: MigrationCallback,\r\n): Promise<{ success: number; errors: number }> {\r\n  const dbName = 'novelist-versioning';\r\n  let success = 0;\r\n  let errors = 0;\r\n\r\n  try {\r\n    const db = await new Promise<IDBDatabase>((resolve, reject) => {\r\n      const request = indexedDB.open(dbName);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new Error('Failed to open IndexedDB'));\r\n    });\r\n\r\n    // Migrate branches\r\n    const branches = await getAllFromStore(db, 'branches');\r\n    onProgress?.({ total: branches.length, completed: 0, errors: 0, currentTask: 'Migrating version history' });\r\n\r\n    for (const branch of branches) {\r\n      if (branch.projectId === projectId) {\r\n        try {\r\n          await versioningService.createBranch(\r\n            branch.projectId,\r\n            branch.name,\r\n            branch.description,\r\n            branch.createdFrom,\r\n          );\r\n          success++;\r\n        } catch (error) {\r\n          errors++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Migrate chapter versions\r\n    const versions = await getAllFromStore(db, 'versions');\r\n    for (const version of versions) {\r\n      try {\r\n        await versioningService.saveVersion(\r\n          version.chapterId,\r\n          version.content,\r\n          version.title,\r\n          version.message,\r\n          version.branchId,\r\n        );\r\n        success++;\r\n      } catch (error) {\r\n        errors++;\r\n      }\r\n    }\r\n\r\n    db.close();\r\n  } catch (error) {\r\n    logger.error('Failed to migrate versioning', { component: 'Migration' }, error as Error);\r\n  }\r\n\r\n  return { success, errors };\r\n}\r\n\r\n/**\r\n * Helper function to get all records from a store\r\n */\r\nasync function getAllFromStore(db: IDBDatabase, storeName: string): Promise<any[]> {\r\n  try {\r\n    if (!db.objectStoreNames.contains(storeName)) {\r\n      return [];\r\n    }\r\n\r\n    const transaction = db.transaction([storeName], 'readonly');\r\n    const store = transaction.objectStore(storeName);\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.getAll();\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new Error(`Failed to get all from ${storeName}`));\r\n    });\r\n  } catch {\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Main migration function - migrates all data for a project\r\n */\r\nexport async function migrateProjectToTurso(\r\n  projectId: string,\r\n  onProgress?: MigrationCallback,\r\n): Promise<{\r\n  characters: { success: number; errors: number };\r\n  worldBuilding: { success: number; errors: number };\r\n  versioning: { success: number; errors: number };\r\n  total: { success: number; errors: number };\r\n}> {\r\n  logger.info('Starting migration to Turso', { component: 'Migration', projectId });\r\n\r\n  const results = {\r\n    characters: { success: 0, errors: 0 },\r\n    worldBuilding: { success: 0, errors: 0 },\r\n    versioning: { success: 0, errors: 0 },\r\n    total: { success: 0, errors: 0 },\r\n  };\r\n\r\n  try {\r\n    // Migrate characters\r\n    results.characters = await migrateCharacters(projectId, onProgress);\r\n    \r\n    // Migrate world-building\r\n    results.worldBuilding = await migrateWorldBuilding(projectId, onProgress);\r\n    \r\n    // Migrate versioning\r\n    results.versioning = await migrateVersioning(projectId, onProgress);\r\n\r\n    // Calculate totals\r\n    results.total.success =\r\n      results.characters.success + results.worldBuilding.success + results.versioning.success;\r\n    results.total.errors =\r\n      results.characters.errors + results.worldBuilding.errors + results.versioning.errors;\r\n\r\n    logger.info('Migration completed', { component: 'Migration', results });\r\n  } catch (error) {\r\n    logger.error('Migration failed', { component: 'Migration' }, error as Error);\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n/**\r\n * Check if IndexedDB databases exist (to determine if migration is needed)\r\n */\r\nexport async function checkIndexedDBExists(): Promise<{\r\n  characters: boolean;\r\n  worldBuilding: boolean;\r\n  versioning: boolean;\r\n  publishing: boolean;\r\n  writingAssistant: boolean;\r\n}> {\r\n  const databases = await indexedDB.databases();\r\n  const dbNames = databases.map((db) => db.name);\r\n\r\n  return {\r\n    characters: dbNames.includes('novelist-characters'),\r\n    worldBuilding: dbNames.includes('novelist-world-building'),\r\n    versioning: dbNames.includes('novelist-versioning'),\r\n    publishing: dbNames.includes('novelist-publishing-analytics'),\r\n    writingAssistant: dbNames.includes('novelist-writing-assistant'),\r\n  };\r\n}\r\n\r\n/**\r\n * Clear IndexedDB data after successful migration\r\n */\r\nexport async function clearIndexedDBData(): Promise<void> {\r\n  const dbNames = [\r\n    'novelist-characters',\r\n    'novelist-world-building',\r\n    'novelist-versioning',\r\n    'novelist-publishing-analytics',\r\n    'novelist-writing-assistant',\r\n  ];\r\n\r\n  for (const dbName of dbNames) {\r\n    try {\r\n      await new Promise<void>((resolve, reject) => {\r\n        const request = indexedDB.deleteDatabase(dbName);\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(new Error(`Failed to delete ${dbName}`));\r\n      });\r\n      logger.info('Deleted IndexedDB database', { component: 'Migration', dbName });\r\n    } catch (error) {\r\n      logger.error('Failed to delete IndexedDB', { component: 'Migration', dbName }, error as Error);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\chapters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\characters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\projects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\publishing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\vectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\versioning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\world-building.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\schemas\\writing-assistant.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\__tests__\\vector-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\character-service.ts","messages":[{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `character-service.ts` to same directory as `../drizzle` or consider making `../drizzle` a package.","line":11,"column":34,"nodeType":"Literal","messageId":"noAllowed","endLine":11,"endColumn":46},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `character-service.ts` to same directory as `../schemas` or consider making `../schemas` a package.","line":12,"column":69,"nodeType":"Literal","messageId":"noAllowed","endLine":12,"endColumn":81}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Character Service for Turso Database\r\n * Handles all character data persistence using Drizzle ORM\r\n */\r\nimport { eq } from 'drizzle-orm';\r\n\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\nimport type { Character, CharacterRelationship } from '@/types';\r\n\r\nimport { getDrizzleClient } from '../drizzle';\r\nimport { characters, type CharacterRow, type NewCharacterRow } from '../schemas';\r\n\r\nclass CharacterService {\r\n  /**\r\n   * Initialize the service (no-op for Turso, connection is managed by getDrizzleClient)\r\n   */\r\n  public async init(): Promise<void> {\r\n    // Connection is handled by getDrizzleClient\r\n    logger.info('Character service initialized', { component: 'CharacterService' });\r\n  }\r\n\r\n  /**\r\n   * Create a new character\r\n   */\r\n  public async createCharacter(character: Omit<Character, 'id'>): Promise<Character> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      throw new Error('Database not configured. Please configure Turso connection.');\r\n    }\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      const newCharacter: NewCharacterRow = {\r\n        id,\r\n        projectId: character.projectId,\r\n        name: character.name,\r\n        role: character.role,\r\n        description: character.description || null,\r\n        personality: character.personality || null,\r\n        background: character.background || null,\r\n        goals: character.goals || null,\r\n        conflicts: character.conflicts || null,\r\n        arc: character.arc || null,\r\n        appearance: character.appearance || null,\r\n        age: character.age || null,\r\n        occupation: character.occupation || null,\r\n        skills: character.skills || null,\r\n        weaknesses: character.weaknesses || null,\r\n        relationships: character.relationships || null,\r\n        notes: character.notes || null,\r\n        imageUrl: character.imageUrl || null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      await db.insert(characters).values(newCharacter);\r\n\r\n      logger.info('Character created', { component: 'CharacterService', characterId: id });\r\n\r\n      return this.mapRowToCharacter(newCharacter as CharacterRow);\r\n    } catch (error) {\r\n      logger.error('Failed to create character', { component: 'CharacterService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all characters for a project\r\n   */\r\n  public async getCharactersByProjectId(projectId: string): Promise<Character[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const rows = await db.select().from(characters).where(eq(characters.projectId, projectId));\r\n      return rows.map((row) => this.mapRowToCharacter(row));\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to get characters',\r\n        { component: 'CharacterService', projectId },\r\n        error as Error,\r\n      );\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a character by ID\r\n   */\r\n  public async getCharacterById(characterId: string): Promise<Character | null> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const rows = await db.select().from(characters).where(eq(characters.id, characterId));\r\n      return rows.length > 0 ? this.mapRowToCharacter(rows[0]) : null;\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to get character',\r\n        { component: 'CharacterService', characterId },\r\n        error as Error,\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a character\r\n   */\r\n  public async updateCharacter(characterId: string, updates: Partial<Character>): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      throw new Error('Database not configured');\r\n    }\r\n\r\n    try {\r\n      const updateData: Partial<CharacterRow> = {\r\n        ...updates,\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n\r\n      await db.update(characters).set(updateData).where(eq(characters.id, characterId));\r\n\r\n      logger.info('Character updated', { component: 'CharacterService', characterId });\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to update character',\r\n        { component: 'CharacterService', characterId },\r\n        error as Error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a character\r\n   */\r\n  public async deleteCharacter(characterId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      throw new Error('Database not configured');\r\n    }\r\n\r\n    try {\r\n      await db.delete(characters).where(eq(characters.id, characterId));\r\n      logger.info('Character deleted', { component: 'CharacterService', characterId });\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to delete character',\r\n        { component: 'CharacterService', characterId },\r\n        error as Error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search characters by name\r\n   */\r\n  public async searchCharacters(projectId: string, searchTerm: string): Promise<Character[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      // Get all characters for the project and filter in memory\r\n      // SQLite doesn't have full-text search out of the box\r\n      const allCharacters = await this.getCharactersByProjectId(projectId);\r\n      const lowerSearch = searchTerm.toLowerCase();\r\n\r\n      return allCharacters.filter(\r\n        (char) =>\r\n          char.name.toLowerCase().includes(lowerSearch) ||\r\n          char.description?.toLowerCase().includes(lowerSearch) ||\r\n          char.role.toLowerCase().includes(lowerSearch),\r\n      );\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to search characters',\r\n        { component: 'CharacterService', projectId, searchTerm },\r\n        error as Error,\r\n      );\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete all characters for a project\r\n   */\r\n  public async deleteCharactersByProjectId(projectId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) {\r\n      throw new Error('Database not configured');\r\n    }\r\n\r\n    try {\r\n      await db.delete(characters).where(eq(characters.projectId, projectId));\r\n      logger.info('Characters deleted for project', { component: 'CharacterService', projectId });\r\n    } catch (error) {\r\n      logger.error(\r\n        'Failed to delete characters',\r\n        { component: 'CharacterService', projectId },\r\n        error as Error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map database row to Character type\r\n   */\r\n  private mapRowToCharacter(row: CharacterRow): Character {\r\n    return {\r\n      id: row.id,\r\n      projectId: row.projectId,\r\n      name: row.name,\r\n      role: row.role as Character['role'],\r\n      description: row.description || undefined,\r\n      personality: row.personality || undefined,\r\n      background: row.background || undefined,\r\n      goals: row.goals || undefined,\r\n      conflicts: row.conflicts || undefined,\r\n      arc: row.arc || undefined,\r\n      appearance: row.appearance || undefined,\r\n      age: row.age || undefined,\r\n      occupation: row.occupation || undefined,\r\n      skills: row.skills || undefined,\r\n      weaknesses: row.weaknesses || undefined,\r\n      relationships: (row.relationships as CharacterRelationship[]) || undefined,\r\n      notes: row.notes || undefined,\r\n      imageUrl: row.imageUrl || undefined,\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const characterService = new CharacterService();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\project-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\publishing-service.ts","messages":[{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `publishing-service.ts` to same directory as `../drizzle` or consider making `../drizzle` a package.","line":10,"column":34,"nodeType":"Literal","messageId":"noAllowed","endLine":10,"endColumn":46},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `publishing-service.ts` to same directory as `../schemas` or consider making `../schemas` a package.","line":11,"column":66,"nodeType":"Literal","messageId":"noAllowed","endLine":11,"endColumn":78},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1762,1765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1762,1765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4584,4587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4584,4587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6471,6474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6471,6474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7184,7187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7184,7187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Publishing Analytics Service for Turso Database\r\n * Handles publishing metrics, platform status, and export history using Drizzle ORM\r\n */\r\nimport { eq, desc, and } from 'drizzle-orm';\r\n\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\n\r\nimport { getDrizzleClient } from '../drizzle';\r\nimport { publishingMetrics, platformStatus, exportHistory } from '../schemas';\r\n\r\nclass PublishingService {\r\n  public async init(): Promise<void> {\r\n    logger.info('Publishing service initialized', { component: 'PublishingService' });\r\n  }\r\n\r\n  // ==================== Publishing Metrics ====================\r\n\r\n  public async recordMetric(\r\n    projectId: string,\r\n    platform: string,\r\n    metricType: string,\r\n    value: number,\r\n    unit?: string,\r\n    period?: string,\r\n    metadata?: Record<string, unknown>,\r\n  ): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      await db.insert(publishingMetrics).values({\r\n        id,\r\n        projectId,\r\n        platform,\r\n        metricType,\r\n        value,\r\n        unit: unit || null,\r\n        period: period || null,\r\n        metadata: metadata || null,\r\n        recordedAt: now,\r\n        createdAt: now,\r\n      });\r\n\r\n      logger.info('Metric recorded', { component: 'PublishingService', projectId, metricType });\r\n    } catch (error) {\r\n      logger.error('Failed to record metric', { component: 'PublishingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getMetrics(\r\n    projectId: string,\r\n    platform?: string,\r\n    metricType?: string,\r\n  ): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const query = db.select().from(publishingMetrics).where(eq(publishingMetrics.projectId, projectId));\r\n\r\n      const rows = await query.orderBy(desc(publishingMetrics.recordedAt));\r\n\r\n      // Filter in memory if needed\r\n      let filtered = rows;\r\n      if (platform) {\r\n        filtered = filtered.filter(row => row.platform === platform);\r\n      }\r\n      if (metricType) {\r\n        filtered = filtered.filter(row => row.metricType === metricType);\r\n      }\r\n\r\n      return filtered;\r\n    } catch (error) {\r\n      logger.error('Failed to get metrics', { component: 'PublishingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ==================== Platform Status ====================\r\n\r\n  public async updatePlatformStatus(\r\n    projectId: string,\r\n    platform: string,\r\n    status: string,\r\n    publishedUrl?: string,\r\n    errorMessage?: string,\r\n    configuration?: Record<string, unknown>,\r\n    metrics?: { views?: number; downloads?: number; revenue?: number; rating?: number },\r\n  ): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const now = new Date().toISOString();\r\n\r\n      // Check if platform status exists\r\n      const existing = await db\r\n        .select()\r\n        .from(platformStatus)\r\n        .where(and(eq(platformStatus.projectId, projectId), eq(platformStatus.platform, platform)));\r\n\r\n      if (existing.length > 0) {\r\n        // Update existing\r\n        await db\r\n          .update(platformStatus)\r\n          .set({\r\n            status,\r\n            publishedUrl: publishedUrl || null,\r\n            lastSyncedAt: now,\r\n            errorMessage: errorMessage || null,\r\n            configuration: configuration || null,\r\n            metrics: metrics || null,\r\n            updatedAt: now,\r\n          })\r\n          .where(eq(platformStatus.id, existing[0].id));\r\n      } else {\r\n        // Create new\r\n        const id = generateSecureId();\r\n        await db.insert(platformStatus).values({\r\n          id,\r\n          projectId,\r\n          platform,\r\n          status,\r\n          publishedUrl: publishedUrl || null,\r\n          lastSyncedAt: now,\r\n          errorMessage: errorMessage || null,\r\n          configuration: configuration || null,\r\n          metrics: metrics || null,\r\n          createdAt: now,\r\n          updatedAt: now,\r\n        });\r\n      }\r\n\r\n      logger.info('Platform status updated', { component: 'PublishingService', projectId, platform });\r\n    } catch (error) {\r\n      logger.error('Failed to update platform status', { component: 'PublishingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getPlatformStatus(projectId: string, platform?: string): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      let rows;\r\n      if (platform) {\r\n        rows = await db\r\n          .select()\r\n          .from(platformStatus)\r\n          .where(and(eq(platformStatus.projectId, projectId), eq(platformStatus.platform, platform)));\r\n      } else {\r\n        rows = await db.select().from(platformStatus).where(eq(platformStatus.projectId, projectId));\r\n      }\r\n\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get platform status', { component: 'PublishingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ==================== Export History ====================\r\n\r\n  public async createExport(\r\n    projectId: string,\r\n    format: string,\r\n    metadata?: Record<string, unknown>,\r\n  ): Promise<string> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      await db.insert(exportHistory).values({\r\n        id,\r\n        projectId,\r\n        format,\r\n        status: 'pending',\r\n        fileUrl: null,\r\n        fileSize: null,\r\n        errorMessage: null,\r\n        metadata: metadata || null,\r\n        createdAt: now,\r\n        completedAt: null,\r\n      });\r\n\r\n      logger.info('Export created', { component: 'PublishingService', projectId, format });\r\n      return id;\r\n    } catch (error) {\r\n      logger.error('Failed to create export', { component: 'PublishingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async updateExport(\r\n    exportId: string,\r\n    status: string,\r\n    fileUrl?: string,\r\n    fileSize?: number,\r\n    errorMessage?: string,\r\n  ): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const updates: any = { status };\r\n      if (fileUrl) updates.fileUrl = fileUrl;\r\n      if (fileSize) updates.fileSize = fileSize;\r\n      if (errorMessage) updates.errorMessage = errorMessage;\r\n      if (status === 'completed' || status === 'failed') {\r\n        updates.completedAt = new Date().toISOString();\r\n      }\r\n\r\n      await db.update(exportHistory).set(updates).where(eq(exportHistory.id, exportId));\r\n\r\n      logger.info('Export updated', { component: 'PublishingService', exportId, status });\r\n    } catch (error) {\r\n      logger.error('Failed to update export', { component: 'PublishingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getExportHistory(projectId: string): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db\r\n        .select()\r\n        .from(exportHistory)\r\n        .where(eq(exportHistory.projectId, projectId))\r\n        .orderBy(desc(exportHistory.createdAt));\r\n\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get export history', { component: 'PublishingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async deleteExport(exportId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(exportHistory).where(eq(exportHistory.id, exportId));\r\n      logger.info('Export deleted', { component: 'PublishingService', exportId });\r\n    } catch (error) {\r\n      logger.error('Failed to delete export', { component: 'PublishingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const publishingService = new PublishingService();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\vector-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\versioning-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'and' is defined but never used.","line":5,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":23},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `versioning-service.ts` to same directory as `../drizzle` or consider making `../drizzle` a package.","line":11,"column":34,"nodeType":"Literal","messageId":"noAllowed","endLine":11,"endColumn":46},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `versioning-service.ts` to same directory as `../schemas` or consider making `../schemas` a package.","line":12,"column":43,"nodeType":"Literal","messageId":"noAllowed","endLine":12,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2946,2949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2946,2949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3080,3083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3080,3083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4535,4538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4535,4538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4649,4652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4649,4652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":172,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5694,5697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5694,5697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5808,5811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5808,5811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Versioning Service for Turso Database\r\n * Handles chapter versions and branches using Drizzle ORM\r\n */\r\nimport { eq, desc, and } from 'drizzle-orm';\r\n\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\nimport type { ChapterVersion, Branch } from '@/types';\r\n\r\nimport { getDrizzleClient } from '../drizzle';\r\nimport { chapterVersions, branches } from '../schemas';\r\n\r\nclass VersioningService {\r\n  private static instance: VersioningService;\r\n\r\n  public static getInstance(): VersioningService {\r\n    VersioningService.instance ??= new VersioningService();\r\n    return VersioningService.instance;\r\n  }\r\n\r\n  private getUserName(): string {\r\n    try {\r\n      const settings = JSON.parse(localStorage.getItem('novelist_settings') ?? '{}') as Record<string, unknown>;\r\n      const userName = (settings.userName as string) ?? (settings.authorName as string);\r\n      return userName ?? 'Anonymous User';\r\n    } catch {\r\n      return 'Anonymous User';\r\n    }\r\n  }\r\n\r\n  public async init(): Promise<void> {\r\n    logger.info('Versioning service initialized', { component: 'VersioningService' });\r\n  }\r\n\r\n  // ==================== Chapter Versions ====================\r\n\r\n  public async saveVersion(\r\n    chapterId: string,\r\n    content: string,\r\n    title: string,\r\n    message?: string,\r\n    branchId?: string,\r\n    type: string = 'manual',\r\n    summary?: string,\r\n    status?: string,\r\n  ): Promise<ChapterVersion> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const versions = await this.getVersionsByChapterId(chapterId);\r\n      const versionNumber = versions.length + 1;\r\n      const id = generateSecureId();\r\n      \r\n      const wordCount = content.split(/\\s+/).filter(w => w.length > 0).length;\r\n      const charCount = content.length;\r\n      const contentHash = await this.generateSimpleHash(content);\r\n\r\n      const newVersion = {\r\n        id,\r\n        chapterId,\r\n        versionNumber,\r\n        content,\r\n        title,\r\n        summary: summary || null,\r\n        status: status || null,\r\n        message: message || null,\r\n        authorName: this.getUserName(),\r\n        type,\r\n        contentHash,\r\n        wordCount,\r\n        charCount,\r\n        branchId: branchId || null,\r\n        parentVersionId: versions.length > 0 ? versions[0].id : null,\r\n        tags: null,\r\n        metadata: null,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n\r\n      await db.insert(chapterVersions).values(newVersion);\r\n\r\n      logger.info('Version saved', { component: 'VersioningService', chapterId, versionNumber });\r\n\r\n      return {\r\n        id: newVersion.id,\r\n        chapterId: newVersion.chapterId,\r\n        versionNumber: newVersion.versionNumber,\r\n        content: newVersion.content,\r\n        title: newVersion.title,\r\n        summary: newVersion.summary || undefined,\r\n        status: newVersion.status as any,\r\n        message: newVersion.message || undefined,\r\n        authorName: newVersion.authorName,\r\n        type: newVersion.type as any,\r\n        contentHash: newVersion.contentHash || '',\r\n        wordCount: newVersion.wordCount || 0,\r\n        charCount: newVersion.charCount || 0,\r\n        timestamp: new Date(newVersion.createdAt),\r\n        branchId: newVersion.branchId || undefined,\r\n        parentVersionId: newVersion.parentVersionId || undefined,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to save version', { component: 'VersioningService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  private async generateSimpleHash(content: string): Promise<string> {\r\n    // Simple hash for content identification\r\n    let hash = 0;\r\n    for (let i = 0; i < content.length; i++) {\r\n      const char = content.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    return hash.toString(36);\r\n  }\r\n\r\n  public async getVersionsByChapterId(chapterId: string): Promise<ChapterVersion[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db\r\n        .select()\r\n        .from(chapterVersions)\r\n        .where(eq(chapterVersions.chapterId, chapterId))\r\n        .orderBy(desc(chapterVersions.createdAt));\r\n\r\n      return rows.map((row) => ({\r\n        id: row.id,\r\n        chapterId: row.chapterId,\r\n        versionNumber: row.versionNumber,\r\n        content: row.content,\r\n        title: row.title,\r\n        summary: row.summary || undefined,\r\n        status: row.status as any,\r\n        message: row.message || undefined,\r\n        authorName: row.authorName,\r\n        type: (row.type as any) || 'manual',\r\n        contentHash: row.contentHash || '',\r\n        wordCount: row.wordCount || 0,\r\n        charCount: row.charCount || 0,\r\n        timestamp: new Date(row.createdAt),\r\n        branchId: row.branchId || undefined,\r\n        parentVersionId: row.parentVersionId || undefined,\r\n      }));\r\n    } catch (error) {\r\n      logger.error('Failed to get versions', { component: 'VersioningService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async getVersionById(versionId: string): Promise<ChapterVersion | null> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return null;\r\n\r\n    try {\r\n      const rows = await db.select().from(chapterVersions).where(eq(chapterVersions.id, versionId));\r\n\r\n      if (rows.length === 0) return null;\r\n\r\n      const row = rows[0];\r\n      return {\r\n        id: row.id,\r\n        chapterId: row.chapterId,\r\n        versionNumber: row.versionNumber,\r\n        content: row.content,\r\n        title: row.title,\r\n        summary: row.summary || undefined,\r\n        status: row.status as any,\r\n        message: row.message || undefined,\r\n        authorName: row.authorName,\r\n        type: (row.type as any) || 'manual',\r\n        contentHash: row.contentHash || '',\r\n        wordCount: row.wordCount || 0,\r\n        charCount: row.charCount || 0,\r\n        timestamp: new Date(row.createdAt),\r\n        branchId: row.branchId || undefined,\r\n        parentVersionId: row.parentVersionId || undefined,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to get version', { component: 'VersioningService' }, error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async deleteVersion(versionId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(chapterVersions).where(eq(chapterVersions.id, versionId));\r\n      logger.info('Version deleted', { component: 'VersioningService', versionId });\r\n    } catch (error) {\r\n      logger.error('Failed to delete version', { component: 'VersioningService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ==================== Branches ====================\r\n\r\n  public async createBranch(\r\n    projectId: string,\r\n    name: string,\r\n    description?: string,\r\n    createdFrom?: string,\r\n  ): Promise<Branch> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      const newBranch = {\r\n        id,\r\n        projectId,\r\n        name,\r\n        description: description || null,\r\n        isActive: false,\r\n        createdFrom: createdFrom || null,\r\n        createdBy: this.getUserName(),\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      await db.insert(branches).values(newBranch);\r\n\r\n      logger.info('Branch created', { component: 'VersioningService', branchId: id });\r\n\r\n      return {\r\n        id: newBranch.id,\r\n        projectId: newBranch.projectId,\r\n        name: newBranch.name,\r\n        description: newBranch.description || undefined,\r\n        isActive: newBranch.isActive,\r\n        createdAt: newBranch.createdAt,\r\n        createdBy: newBranch.createdBy,\r\n        createdFrom: newBranch.createdFrom || undefined,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to create branch', { component: 'VersioningService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getBranchesByProjectId(projectId: string): Promise<Branch[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db.select().from(branches).where(eq(branches.projectId, projectId));\r\n\r\n      return rows.map((row) => ({\r\n        id: row.id,\r\n        projectId: row.projectId,\r\n        name: row.name,\r\n        description: row.description || undefined,\r\n        isActive: row.isActive,\r\n        createdAt: row.createdAt,\r\n        createdBy: row.createdBy,\r\n        createdFrom: row.createdFrom || undefined,\r\n      }));\r\n    } catch (error) {\r\n      logger.error('Failed to get branches', { component: 'VersioningService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async setActiveBranch(projectId: string, branchId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      // Deactivate all branches for the project\r\n      await db.update(branches).set({ isActive: false }).where(eq(branches.projectId, projectId));\r\n\r\n      // Activate the selected branch\r\n      await db.update(branches).set({ isActive: true }).where(eq(branches.id, branchId));\r\n\r\n      logger.info('Active branch set', { component: 'VersioningService', branchId });\r\n    } catch (error) {\r\n      logger.error('Failed to set active branch', { component: 'VersioningService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async deleteBranch(branchId: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(branches).where(eq(branches.id, branchId));\r\n      logger.info('Branch deleted', { component: 'VersioningService', branchId });\r\n    } catch (error) {\r\n      logger.error('Failed to delete branch', { component: 'VersioningService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const versioningService = VersioningService.getInstance();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\world-building-service.ts","messages":[{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `world-building-service.ts` to same directory as `../drizzle` or consider making `../drizzle` a package.","line":10,"column":34,"nodeType":"Literal","messageId":"noAllowed","endLine":10,"endColumn":46},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `world-building-service.ts` to same directory as `../schemas` or consider making `../schemas` a package.","line":21,"column":8,"nodeType":"Literal","messageId":"noAllowed","endLine":21,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * World-Building Service for Turso Database\r\n * Handles all world-building data persistence using Drizzle ORM\r\n */\r\nimport { eq } from 'drizzle-orm';\r\n\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\n\r\nimport { getDrizzleClient } from '../drizzle';\r\nimport {\r\n  worldBuildingProjects,\r\n  locations,\r\n  cultures,\r\n  type WorldBuildingProjectRow,\r\n  type NewWorldBuildingProjectRow,\r\n  type LocationRow,\r\n  type NewLocationRow,\r\n  type CultureRow,\r\n  type NewCultureRow,\r\n} from '../schemas';\r\n\r\nclass WorldBuildingService {\r\n  public async init(): Promise<void> {\r\n    logger.info('World-building service initialized', { component: 'WorldBuildingService' });\r\n  }\r\n\r\n  // ==================== World-Building Projects ====================\r\n\r\n  public async createProject(name: string, projectId: string, description?: string): Promise<WorldBuildingProjectRow> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      const newProject: NewWorldBuildingProjectRow = {\r\n        id,\r\n        projectId,\r\n        name,\r\n        description: description || null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      await db.insert(worldBuildingProjects).values(newProject);\r\n      return newProject as WorldBuildingProjectRow;\r\n    } catch (error) {\r\n      logger.error('Failed to create world-building project', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getProjectsByProjectId(projectId: string): Promise<WorldBuildingProjectRow[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db.select().from(worldBuildingProjects).where(eq(worldBuildingProjects.projectId, projectId));\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get world-building projects', { component: 'WorldBuildingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async updateProject(id: string, updates: Partial<Omit<WorldBuildingProjectRow, 'id' | 'projectId' | 'createdAt'>>): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.update(worldBuildingProjects).set({ ...updates, updatedAt: new Date().toISOString() }).where(eq(worldBuildingProjects.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to update world-building project', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async deleteProject(id: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(worldBuildingProjects).where(eq(worldBuildingProjects.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to delete world-building project', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ==================== Locations ====================\r\n\r\n  public async createLocation(locationData: Omit<NewLocationRow, 'id' | 'createdAt' | 'updatedAt'>): Promise<LocationRow> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      const newLocation: NewLocationRow = {\r\n        id,\r\n        worldBuildingProjectId: locationData.worldBuildingProjectId,\r\n        name: locationData.name,\r\n        type: locationData.type,\r\n        description: locationData.description || null,\r\n        climate: locationData.climate || null,\r\n        geography: locationData.geography || null,\r\n        population: locationData.population || null,\r\n        government: locationData.government || null,\r\n        economy: locationData.economy || null,\r\n        culture: locationData.culture || null,\r\n        history: locationData.history || null,\r\n        significance: locationData.significance || null,\r\n        parentLocationId: locationData.parentLocationId || null,\r\n        coordinates: locationData.coordinates || null,\r\n        tags: locationData.tags || null,\r\n        imageUrl: locationData.imageUrl || null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      await db.insert(locations).values(newLocation);\r\n      return newLocation as LocationRow;\r\n    } catch (error) {\r\n      logger.error('Failed to create location', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getLocationsByProjectId(worldBuildingProjectId: string): Promise<LocationRow[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db.select().from(locations).where(eq(locations.worldBuildingProjectId, worldBuildingProjectId));\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get locations', { component: 'WorldBuildingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async updateLocation(id: string, updates: Partial<Omit<LocationRow, 'id' | 'worldBuildingProjectId' | 'createdAt'>>): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.update(locations).set({ ...updates, updatedAt: new Date().toISOString() }).where(eq(locations.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to update location', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async deleteLocation(id: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(locations).where(eq(locations.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to delete location', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ==================== Cultures ====================\r\n\r\n  public async createCulture(cultureData: Omit<NewCultureRow, 'id' | 'createdAt' | 'updatedAt'>): Promise<CultureRow> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      const newCulture: NewCultureRow = {\r\n        id,\r\n        worldBuildingProjectId: cultureData.worldBuildingProjectId,\r\n        name: cultureData.name,\r\n        description: cultureData.description || null,\r\n        values: cultureData.values || null,\r\n        traditions: cultureData.traditions || null,\r\n        beliefs: cultureData.beliefs || null,\r\n        language: cultureData.language || null,\r\n        socialStructure: cultureData.socialStructure || null,\r\n        customs: cultureData.customs || null,\r\n        arts: cultureData.arts || null,\r\n        technology: cultureData.technology || null,\r\n        locationIds: cultureData.locationIds || null,\r\n        tags: cultureData.tags || null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      };\r\n\r\n      await db.insert(cultures).values(newCulture);\r\n      return newCulture as CultureRow;\r\n    } catch (error) {\r\n      logger.error('Failed to create culture', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getCulturesByProjectId(worldBuildingProjectId: string): Promise<CultureRow[]> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const rows = await db.select().from(cultures).where(eq(cultures.worldBuildingProjectId, worldBuildingProjectId));\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get cultures', { component: 'WorldBuildingService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  public async updateCulture(id: string, updates: Partial<Omit<CultureRow, 'id' | 'worldBuildingProjectId' | 'createdAt'>>): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.update(cultures).set({ ...updates, updatedAt: new Date().toISOString() }).where(eq(cultures.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to update culture', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async deleteCulture(id: string): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db.delete(cultures).where(eq(cultures.id, id));\r\n    } catch (error) {\r\n      logger.error('Failed to delete culture', { component: 'WorldBuildingService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const worldBuildingService = new WorldBuildingService();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\database\\services\\writing-assistant-service.ts","messages":[{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `writing-assistant-service.ts` to same directory as `../drizzle` or consider making `../drizzle` a package.","line":10,"column":34,"nodeType":"Literal","messageId":"noAllowed","endLine":10,"endColumn":46},{"ruleId":"import-x/no-relative-parent-imports","severity":2,"message":"Relative imports from parent directories are not allowed. Please either pass what you're importing through at runtime (dependency injection), move `writing-assistant-service.ts` to same directory as `../schemas` or consider making `../schemas` a package.","line":11,"column":91,"nodeType":"Literal","messageId":"noAllowed","endLine":11,"endColumn":103},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2481,2484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2481,2484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6961,6964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6961,6964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":311,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9664,9667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9664,9667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Writing Assistant Service for Turso Database\r\n * Handles analysis history, user preferences, and suggestion feedback using Drizzle ORM\r\n */\r\nimport { eq, desc, and } from 'drizzle-orm';\r\n\r\nimport { logger } from '@/lib/logging/logger';\r\nimport { generateSecureId } from '@/lib/secure-random';\r\n\r\nimport { getDrizzleClient } from '../drizzle';\r\nimport { analysisHistory, userWritingPreferences, suggestionFeedback, writingGoals } from '../schemas';\r\n\r\nclass WritingAssistantService {\r\n  public async init(): Promise<void> {\r\n    logger.info('Writing assistant service initialized', { component: 'WritingAssistantService' });\r\n  }\r\n\r\n  private getUserId(): string {\r\n    // In a real app, this would come from authentication\r\n    // For now, use a consistent ID from localStorage\r\n    let userId = localStorage.getItem('novelist_user_id');\r\n    if (!userId) {\r\n      userId = generateSecureId();\r\n      localStorage.setItem('novelist_user_id', userId);\r\n    }\r\n    return userId;\r\n  }\r\n\r\n  // ==================== Analysis History ====================\r\n\r\n  public async saveAnalysis(\r\n    chapterId: string,\r\n    projectId: string,\r\n    readabilityScore: number,\r\n    engagementScore: number,\r\n    sentimentScore: number,\r\n    paceScore: number,\r\n    suggestionCount: number,\r\n    suggestionCategories: string[],\r\n    analysisDepth: 'basic' | 'standard' | 'comprehensive',\r\n    contentWordCount: number,\r\n  ): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      await db.insert(analysisHistory).values({\r\n        id,\r\n        userId: this.getUserId(),\r\n        chapterId,\r\n        projectId,\r\n        readabilityScore,\r\n        engagementScore,\r\n        sentimentScore,\r\n        paceScore,\r\n        suggestionCount,\r\n        suggestionCategories,\r\n        acceptedSuggestions: 0,\r\n        dismissedSuggestions: 0,\r\n        analysisDepth,\r\n        contentWordCount,\r\n        timestamp: now,\r\n        createdAt: now,\r\n      });\r\n\r\n      logger.info('Analysis saved', { component: 'WritingAssistantService', chapterId });\r\n    } catch (error) {\r\n      logger.error('Failed to save analysis', { component: 'WritingAssistantService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getAnalysisHistory(\r\n    projectId: string,\r\n    chapterId?: string,\r\n    limit: number = 50,\r\n  ): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const userId = this.getUserId();\r\n      let query;\r\n\r\n      if (chapterId) {\r\n        query = db\r\n          .select()\r\n          .from(analysisHistory)\r\n          .where(\r\n            and(\r\n              eq(analysisHistory.userId, userId),\r\n              eq(analysisHistory.projectId, projectId),\r\n              eq(analysisHistory.chapterId, chapterId),\r\n            ),\r\n          );\r\n      } else {\r\n        query = db\r\n          .select()\r\n          .from(analysisHistory)\r\n          .where(and(eq(analysisHistory.userId, userId), eq(analysisHistory.projectId, projectId)));\r\n      }\r\n\r\n      const rows = await query.orderBy(desc(analysisHistory.timestamp)).limit(limit);\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get analysis history', { component: 'WritingAssistantService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ==================== User Writing Preferences ====================\r\n\r\n  public async savePreferences(preferences: Record<string, unknown>): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const userId = this.getUserId();\r\n      const deviceId = this.getDeviceId();\r\n      const now = new Date().toISOString();\r\n\r\n      // Check if preferences exist\r\n      const existing = await db\r\n        .select()\r\n        .from(userWritingPreferences)\r\n        .where(and(eq(userWritingPreferences.userId, userId), eq(userWritingPreferences.deviceId, deviceId)));\r\n\r\n      const firstExisting = existing[0];\r\n      if (firstExisting) {\r\n        // Update existing\r\n        await db\r\n          .update(userWritingPreferences)\r\n          .set({\r\n            preferences,\r\n            lastSyncedAt: now,\r\n            updatedAt: now,\r\n          })\r\n          .where(eq(userWritingPreferences.id, firstExisting.id));\r\n      } else {\r\n        // Create new\r\n        const id = generateSecureId();\r\n        await db.insert(userWritingPreferences).values({\r\n          id,\r\n          userId,\r\n          preferences,\r\n          lastSyncedAt: now,\r\n          deviceId,\r\n          createdAt: now,\r\n          updatedAt: now,\r\n        });\r\n      }\r\n\r\n      logger.info('Preferences saved', { component: 'WritingAssistantService' });\r\n    } catch (error) {\r\n      logger.error('Failed to save preferences', { component: 'WritingAssistantService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getPreferences(): Promise<Record<string, unknown> | null> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return null;\r\n\r\n    try {\r\n      const userId = this.getUserId();\r\n      const deviceId = this.getDeviceId();\r\n\r\n      const rows = await db\r\n        .select()\r\n        .from(userWritingPreferences)\r\n        .where(and(eq(userWritingPreferences.userId, userId), eq(userWritingPreferences.deviceId, deviceId)));\r\n\r\n      const firstRow = rows[0];\r\n      return firstRow ? (firstRow.preferences as Record<string, unknown>) : null;\r\n    } catch (error) {\r\n      logger.error('Failed to get preferences', { component: 'WritingAssistantService' }, error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // ==================== Suggestion Feedback ====================\r\n\r\n  public async recordSuggestionFeedback(\r\n    suggestionType: string,\r\n    suggestionCategory: string,\r\n    action: 'accepted' | 'dismissed' | 'ignored',\r\n    context?: string,\r\n    chapterId?: string,\r\n    projectId?: string,\r\n  ): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      await db.insert(suggestionFeedback).values({\r\n        id,\r\n        userId: this.getUserId(),\r\n        suggestionType,\r\n        suggestionCategory,\r\n        action,\r\n        context: context || null,\r\n        chapterId: chapterId || null,\r\n        projectId: projectId || null,\r\n        timestamp: now,\r\n        createdAt: now,\r\n      });\r\n\r\n      logger.info('Suggestion feedback recorded', { component: 'WritingAssistantService', action });\r\n    } catch (error) {\r\n      logger.error('Failed to record suggestion feedback', { component: 'WritingAssistantService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getSuggestionFeedback(\r\n    projectId?: string,\r\n    limit: number = 100,\r\n  ): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const userId = this.getUserId();\r\n      let query;\r\n\r\n      if (projectId) {\r\n        query = db\r\n          .select()\r\n          .from(suggestionFeedback)\r\n          .where(and(eq(suggestionFeedback.userId, userId), eq(suggestionFeedback.projectId, projectId)));\r\n      } else {\r\n        query = db.select().from(suggestionFeedback).where(eq(suggestionFeedback.userId, userId));\r\n      }\r\n\r\n      const rows = await query.orderBy(desc(suggestionFeedback.timestamp)).limit(limit);\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get suggestion feedback', { component: 'WritingAssistantService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ==================== Writing Goals ====================\r\n\r\n  public async createGoal(\r\n    goalType: 'daily' | 'weekly' | 'monthly' | 'project',\r\n    targetValue: number,\r\n    unit: 'words' | 'chapters' | 'hours',\r\n    startDate: string,\r\n    endDate?: string,\r\n    projectId?: string,\r\n    metadata?: Record<string, unknown>,\r\n  ): Promise<string> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      const id = generateSecureId();\r\n      const now = new Date().toISOString();\r\n\r\n      await db.insert(writingGoals).values({\r\n        id,\r\n        userId: this.getUserId(),\r\n        projectId: projectId || null,\r\n        goalType,\r\n        targetValue,\r\n        currentValue: 0,\r\n        unit,\r\n        startDate,\r\n        endDate: endDate || null,\r\n        isActive: true,\r\n        metadata: metadata || null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n      });\r\n\r\n      logger.info('Writing goal created', { component: 'WritingAssistantService', goalType });\r\n      return id;\r\n    } catch (error) {\r\n      logger.error('Failed to create goal', { component: 'WritingAssistantService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async updateGoalProgress(goalId: string, currentValue: number): Promise<void> {\r\n    const db = getDrizzleClient();\r\n    if (!db) throw new Error('Database not configured');\r\n\r\n    try {\r\n      await db\r\n        .update(writingGoals)\r\n        .set({\r\n          currentValue,\r\n          updatedAt: new Date().toISOString(),\r\n        })\r\n        .where(eq(writingGoals.id, goalId));\r\n\r\n      logger.info('Goal progress updated', { component: 'WritingAssistantService', goalId });\r\n    } catch (error) {\r\n      logger.error('Failed to update goal progress', { component: 'WritingAssistantService' }, error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getActiveGoals(projectId?: string): Promise<Array<any>> {\r\n    const db = getDrizzleClient();\r\n    if (!db) return [];\r\n\r\n    try {\r\n      const userId = this.getUserId();\r\n      let query;\r\n\r\n      if (projectId) {\r\n        query = db\r\n          .select()\r\n          .from(writingGoals)\r\n          .where(\r\n            and(\r\n              eq(writingGoals.userId, userId),\r\n              eq(writingGoals.projectId, projectId),\r\n              eq(writingGoals.isActive, true),\r\n            ),\r\n          );\r\n      } else {\r\n        query = db\r\n          .select()\r\n          .from(writingGoals)\r\n          .where(and(eq(writingGoals.userId, userId), eq(writingGoals.isActive, true)));\r\n      }\r\n\r\n      const rows = await query;\r\n      return rows;\r\n    } catch (error) {\r\n      logger.error('Failed to get active goals', { component: 'WritingAssistantService' }, error as Error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ==================== Helper Methods ====================\r\n\r\n  private getDeviceId(): string {\r\n    let deviceId = localStorage.getItem('novelist_device_id');\r\n    if (!deviceId) {\r\n      deviceId = generateSecureId();\r\n      localStorage.setItem('novelist_device_id', deviceId);\r\n    }\r\n    return deviceId;\r\n  }\r\n}\r\n\r\nexport const writingAssistantService = new WritingAssistantService();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db\\__tests__\\ai-preferences.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db\\ai-preferences-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db\\ai-preferences.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\db\\schemas\\ai-preferences-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\embeddings\\__tests__\\similarity.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\embeddings\\embedding-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\embeddings\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\embeddings\\similarity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\env-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\epub.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\__tests__\\logging.sentry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\error-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\error-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\errors\\result.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_context' is defined but never used.","line":288,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":288,"endColumn":11,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\hooks\\useAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\hooks\\useScrollLock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\lazy-components.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\lazy-loader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\logging\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\logging\\sanitize-log-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\pwa\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\pwa\\install-prompt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\pwa\\offline-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\secure-random.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\secure-random.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":45,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":45,"endColumn":48,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\analyticsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\featureFlagsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\publishingStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\toastStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\stores\\versioningStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\utils\\retry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[983,986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[983,986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from '@/lib/logging/logger';\n\ninterface RetryOptions {\n  maxAttempts?: number;\n  initialDelayMs?: number;\n  backoffFactor?: number;\n  jitterFactor?: number; // 0 to 1, e.g., 0.5 for 50% jitter\n  retryableStatusCodes?: number[];\n  logLabel?: string;\n}\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxAttempts: 3,\n  initialDelayMs: 1000, // 1 second\n  backoffFactor: 2,\n  jitterFactor: 0.5,\n  retryableStatusCodes: [429, 500, 502, 503, 504], // Too Many Requests, Internal Server Error, Bad Gateway, Service Unavailable, Gateway Timeout\n  logLabel: 'Retryable Operation',\n};\n\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options?: RetryOptions,\n): Promise<T> {\n  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  const { maxAttempts, initialDelayMs, backoffFactor, jitterFactor, retryableStatusCodes, logLabel } = opts;\n\n  let attempt = 0;\n  while (attempt < maxAttempts) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      attempt++;\n      const isLastAttempt = attempt === maxAttempts;\n      \n      let statusCode: number | undefined;\n      // Check for status code in different error structures\n      if (error.response && typeof error.response.status === 'number') {\n        statusCode = error.response.status;\n      } else if (typeof error.status === 'number') {\n        statusCode = error.status;\n      }\n\n      // Determine if the error is retryable\n      const isRetryableError =\n        (statusCode && retryableStatusCodes.includes(statusCode)) ||\n        // Also retry on network errors (no status code)\n        !statusCode ||\n        error.message.includes('NetworkError') || // Browser fetch network errors\n        error.message.includes('Failed to fetch'); // Node.js fetch network errors\n\n\n      if (!isRetryableError || isLastAttempt) {\n        logger.error(`[${logLabel}] Failed after ${attempt} attempts.`, { error, attempt, isRetryableError, statusCode });\n        throw error; // Re-throw if not retryable or max attempts reached\n      }\n\n      let delay = initialDelayMs * (backoffFactor ** (attempt - 1));\n      // Apply jitter\n      const jitter = delay * jitterFactor * (Math.random() - 0.5) * 2; // Random value between -jitterFactor*delay and +jitterFactor*delay\n      delay = Math.max(0, delay + jitter); // Ensure delay is not negative\n\n      logger.warn(`[${logLabel}] Attempt ${attempt} failed. Retrying in ${delay.toFixed(2)}ms...`, { error, attempt, delay, statusCode });\n\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  // This part should theoretically not be reached if maxAttempts is handled correctly within the loop\n  throw new Error(`[${logLabel}] Unexpected error: Failed to complete after ${maxAttempts} attempts.`);\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\lib\\z-index.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\pages\\MetricsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\performance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\__tests__\\ai-analytics-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\__tests__\\ai-config-service.fallback.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\__tests__\\ai-health-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\ai-analytics-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\ai-config-service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_prefs' is defined but never used.","line":206,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":9,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\ai-health-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\openrouter-advanced-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\services\\openrouter-models-service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":567,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":567,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16235,16238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16235,16238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OpenRouter Models Service\n * Dynamic model discovery, caching, and management\n */\n\nimport { getAIConfig } from '@/lib/ai-config';\nimport { logger } from '@/lib/logging/logger';\nimport { withRetry } from '@/lib/utils/retry';\n\nexport interface OpenRouterModel {\n  id: string;\n  canonical_slug: string;\n  name: string;\n  created: number;\n  description: string;\n  context_length: number;\n  architecture: {\n    input_modalities: string[];\n    output_modalities: string[];\n    tokenizer: string;\n    instruct_type: string | null;\n  };\n  pricing: {\n    prompt: string;\n    completion: string;\n    request: string;\n    image: string;\n    web_search: string;\n    internal_reasoning: string;\n    input_cache_read: string;\n    input_cache_write: string;\n  };\n  top_provider: {\n    context_length: number;\n    max_completion_tokens: number;\n    is_moderated: boolean;\n  };\n  per_request_limits: string | null;\n  supported_parameters: string[];\n}\n\nexport interface ModelFilters {\n  provider?: string;\n  contextLength?: { min?: number; max?: number };\n  modalities?: string[];\n  pricing?: { maxPrompt?: number; maxCompletion?: number };\n  search?: string;\n  sortBy?: 'name' | 'context_length' | 'pricing' | 'created';\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface ProviderStatus {\n  id: string;\n  name: string;\n  enabled: boolean;\n  modelsCount: number;\n  avgLatency: number;\n  successRate: number;\n  lastHealthCheck: string;\n  status: 'operational' | 'degraded' | 'outage';\n}\n\nexport interface ModelRecommendation {\n  model: OpenRouterModel;\n  score: number;\n  reasons: string[];\n  taskTypes: string[];\n}\n\nconst CACHE_KEY = 'openrouter_models_cache';\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\nconst FALLBACK_MODELS = [\n  {\n    id: 'openai/gpt-4o',\n    name: 'GPT-4o',\n    description: 'OpenAI latest multimodal model',\n    context_length: 128000,\n    architecture: {\n      input_modalities: ['text', 'image'],\n      output_modalities: ['text'],\n      tokenizer: 'cl100k_base',\n      instruct_type: 'chat',\n    },\n    pricing: {\n      prompt: '2.5',\n      completion: '10.0',\n      request: '0',\n      image: '0',\n      web_search: '0',\n      internal_reasoning: '0',\n      input_cache_read: '0',\n      input_cache_write: '0',\n    },\n    supported_parameters: ['tools', 'tool_choice', 'max_tokens', 'temperature', 'top_p'],\n    top_provider: {\n      context_length: 128000,\n      max_completion_tokens: 16384,\n      is_moderated: true,\n    },\n  },\n  {\n    id: 'anthropic/claude-3-5-sonnet-20241022',\n    name: 'Claude 3.5 Sonnet',\n    description: 'Anthropic advanced reasoning model',\n    context_length: 200000,\n    architecture: {\n      input_modalities: ['text', 'image'],\n      output_modalities: ['text'],\n      tokenizer: 'claude',\n      instruct_type: 'messages',\n    },\n    pricing: {\n      prompt: '3.0',\n      completion: '15.0',\n      request: '0',\n      image: '0',\n      web_search: '0',\n      internal_reasoning: '0',\n      input_cache_read: '0',\n      input_cache_write: '0',\n    },\n    supported_parameters: ['tools', 'tool_choice', 'max_tokens', 'temperature', 'top_p'],\n    top_provider: {\n      context_length: 200000,\n      max_completion_tokens: 8192,\n      is_moderated: true,\n    },\n  },\n  {\n    id: 'google/gemini-2.0-flash-exp',\n    name: 'Gemini 2.0 Flash',\n    description: 'Google latest fast multimodal model',\n    context_length: 1000000,\n    architecture: {\n      input_modalities: ['text', 'image', 'video'],\n      output_modalities: ['text'],\n      tokenizer: 'gemini',\n      instruct_type: 'chat',\n    },\n    pricing: {\n      prompt: '0.075',\n      completion: '0.3',\n      request: '0',\n      image: '0',\n      web_search: '0',\n      internal_reasoning: '0',\n      input_cache_read: '0',\n      input_cache_write: '0',\n    },\n    supported_parameters: ['tools', 'tool_choice', 'max_tokens', 'temperature', 'top_p'],\n    top_provider: {\n      context_length: 1000000,\n      max_completion_tokens: 8192,\n      is_moderated: true,\n    },\n  },\n] as OpenRouterModel[];\n\nexport class OpenRouterModelsService {\n  private static instance: OpenRouterModelsService;\n  private cache: { models: OpenRouterModel[]; timestamp: number } | null = null;\n  private fetchPromise: Promise<OpenRouterModel[]> | null = null;\n\n  private constructor() {\n    this.loadFromCache();\n  }\n\n  public static getInstance(): OpenRouterModelsService {\n    if (!OpenRouterModelsService.instance) {\n      OpenRouterModelsService.instance = new OpenRouterModelsService();\n    }\n    return OpenRouterModelsService.instance;\n  }\n\n  /**\n   * Get all available models from OpenRouter\n   */\n  public async getAvailableModels(): Promise<OpenRouterModel[]> {\n    // Check cache first\n    if (this.isCacheValid()) {\n      return this.cache?.models ?? [];\n    }\n\n    // Check if already fetching\n    if (this.fetchPromise) {\n      return this.fetchPromise;\n    }\n\n    // Start fetching\n    this.fetchPromise = this.fetchModelsFromAPI();\n\n    try {\n      const models = await this.fetchPromise;\n      this.saveToCache(models);\n      return models;\n    } finally {\n      this.fetchPromise = null;\n    }\n  }\n\n  /**\n   * Get models with search and filtering\n   */\n  public async getModelsWithFilters(filters: ModelFilters): Promise<OpenRouterModel[]> {\n    const allModels = await this.getAvailableModels();\n\n    let filteredModels = [...allModels];\n\n    // Provider filter\n    if (filters.provider) {\n      filteredModels = filteredModels.filter(model => model.id.startsWith(filters.provider!));\n    }\n\n    // Search filter\n    if (filters.search) {\n      const searchLower = filters.search.toLowerCase();\n      filteredModels = filteredModels.filter(\n        model =>\n          model.name.toLowerCase().includes(searchLower) ||\n          model.description.toLowerCase().includes(searchLower) ||\n          model.id.toLowerCase().includes(searchLower),\n      );\n    }\n\n    // Context length filter\n    if (filters.contextLength) {\n      if (filters.contextLength.min !== undefined) {\n        filteredModels = filteredModels.filter(\n          model => model.context_length >= filters.contextLength!.min!,\n        );\n      }\n      if (filters.contextLength.max !== undefined) {\n        filteredModels = filteredModels.filter(\n          model => model.context_length <= filters.contextLength!.max!,\n        );\n      }\n    }\n\n    // Modalities filter\n    if (filters.modalities && filters.modalities.length > 0) {\n      filteredModels = filteredModels.filter(model =>\n        filters.modalities!.some(\n          modality =>\n            model.architecture.input_modalities.includes(modality) ||\n            model.architecture.output_modalities.includes(modality),\n        ),\n      );\n    }\n\n    // Pricing filter\n    if (filters.pricing) {\n      if (filters.pricing.maxPrompt !== undefined) {\n        filteredModels = filteredModels.filter(\n          model => parseFloat(model.pricing.prompt) <= filters.pricing!.maxPrompt!,\n        );\n      }\n      if (filters.pricing.maxCompletion !== undefined) {\n        filteredModels = filteredModels.filter(\n          model => parseFloat(model.pricing.completion) <= filters.pricing!.maxCompletion!,\n        );\n      }\n    }\n\n    // Sorting\n    if (filters.sortBy) {\n      filteredModels.sort((a, b) => {\n        let aValue: number | string;\n        let bValue: number | string;\n\n        switch (filters.sortBy) {\n          case 'name':\n            aValue = a.name;\n            bValue = b.name;\n            break;\n          case 'context_length':\n            aValue = a.context_length;\n            bValue = b.context_length;\n            break;\n          case 'pricing':\n            aValue = parseFloat(a.pricing.prompt);\n            bValue = parseFloat(b.pricing.prompt);\n            break;\n          case 'created':\n            aValue = a.created;\n            bValue = b.created;\n            break;\n          default:\n            return 0;\n        }\n\n        if (typeof aValue === 'string' && typeof bValue === 'string') {\n          return filters.sortOrder === 'desc'\n            ? bValue.localeCompare(aValue)\n            : aValue.localeCompare(bValue);\n        } else {\n          return filters.sortOrder === 'desc'\n            ? (bValue as number) - (aValue as number)\n            : (aValue as number) - (bValue as number);\n        }\n      });\n    }\n\n    return filteredModels;\n  }\n\n  /**\n   * Get model recommendations based on task type\n   */\n  public async getModelRecommendations(\n    taskType: string,\n    count: number = 5,\n  ): Promise<ModelRecommendation[]> {\n    const allModels = await this.getAvailableModels();\n    const recommendations: ModelRecommendation[] = [];\n\n    // Task type mapping to model characteristics\n    const taskMappings: Record<\n      string,\n      {\n        modalities?: string[];\n        features?: string[];\n        context?: number;\n        pricing?: string;\n        speed?: string;\n      }\n    > = {\n      chat: { modalities: ['text'], context: 8000, pricing: 'low' },\n      coding: { modalities: ['text'], features: ['tools'], context: 32000, pricing: 'medium' },\n      reasoning: { context: 128000, features: ['tools'], pricing: 'high' },\n      multimodal: { modalities: ['image', 'video'], context: 16000, pricing: 'high' },\n      fast: { pricing: 'low', speed: 'high' },\n      creative: { context: 32000, pricing: 'medium' },\n      analysis: { context: 128000, pricing: 'high' },\n      embedding: { modalities: ['text'], features: ['embeddings'] },\n    };\n\n    const taskConfig = taskMappings[taskType as keyof typeof taskMappings];\n    if (!taskConfig) {\n      return [];\n    }\n\n    for (const model of allModels) {\n      let score = 0;\n      const reasons: string[] = [];\n      const taskTypes: string[] = [];\n\n      // Score based on task match\n      if (taskConfig.modalities) {\n        const hasModalities = taskConfig.modalities.some((modality: string) =>\n          model.architecture.input_modalities.includes(modality),\n        );\n        if (hasModalities) {\n          score += 30;\n          reasons.push(`Supports ${taskConfig.modalities.join(', ')}`);\n          taskTypes.push('multimodal');\n        }\n      }\n\n      if (taskConfig.features) {\n        const hasFeatures = taskConfig.features.some(\n          (feature: string) =>\n            model.supported_parameters.includes(feature) || model.id.includes(feature),\n        );\n        if (hasFeatures) {\n          score += 25;\n          reasons.push(`Supports ${taskConfig.features.join(', ')}`);\n          taskTypes.push('advanced');\n        }\n      }\n\n      // Score based on context length\n      if (taskConfig.context) {\n        if (model.context_length >= taskConfig.context) {\n          score += 20;\n          reasons.push(`High context window (${model.context_length.toLocaleString()} tokens)`);\n          taskTypes.push('long-context');\n        }\n      }\n\n      // Score based on pricing\n      if (taskConfig.pricing) {\n        const promptPrice = parseFloat(model.pricing.prompt);\n        const completionPrice = parseFloat(model.pricing.completion);\n        const avgPrice = (promptPrice + completionPrice) / 2;\n\n        switch (taskConfig.pricing) {\n          case 'low':\n            if (avgPrice <= 0.1) {\n              score += 15;\n              reasons.push('Cost-effective');\n              taskTypes.push('economical');\n            }\n            break;\n          case 'medium':\n            if (avgPrice <= 1.0) {\n              score += 10;\n              reasons.push('Good value');\n              taskTypes.push('balanced');\n            }\n            break;\n          case 'high':\n            if (avgPrice > 1.0) {\n              score += 10;\n              reasons.push('Premium quality');\n              taskTypes.push('premium');\n            }\n            break;\n        }\n      }\n\n      // Popularity boost (models from major providers)\n      const majorProviders = ['openai', 'anthropic', 'google'];\n      if (majorProviders.some(provider => model.id.startsWith(provider))) {\n        score += 10;\n        reasons.push('Established provider');\n        taskTypes.push('reliable');\n      }\n\n      if (score > 0) {\n        recommendations.push({\n          model,\n          score,\n          reasons,\n          taskTypes: [...new Set(taskTypes)],\n        });\n      }\n    }\n\n    // Sort by score and return top recommendations\n    return recommendations.sort((a, b) => b.score - a.score).slice(0, count);\n  }\n\n  /**\n   * Get provider statistics\n   */\n  public async getProviderStatuses(): Promise<ProviderStatus[]> {\n    const allModels = await this.getAvailableModels();\n    const providerMap = new Map<string, OpenRouterModel[]>();\n\n    // Group models by provider\n    for (const model of allModels) {\n      const provider = model.id.split('/')[0] || '';\n      if (!providerMap.has(provider)) {\n        providerMap.set(provider, []);\n      }\n      providerMap.get(provider)!.push(model);\n    }\n\n    const config = getAIConfig();\n    const statuses: ProviderStatus[] = [];\n\n    for (const [provider, models] of providerMap) {\n      const providerConfig = config.providers[provider as keyof typeof config.providers];\n\n      statuses.push({\n        id: provider,\n        name: provider.charAt(0).toUpperCase() + provider.slice(1),\n        enabled: providerConfig?.enabled ?? false,\n        modelsCount: models.length,\n        avgLatency: 0,\n        successRate: 0,\n        lastHealthCheck: new Date().toISOString(),\n        status: providerConfig?.enabled ? 'operational' : 'outage',\n      });\n    }\n\n    return statuses.sort((a, b) => a.name.localeCompare(b.name));\n  }\n\n  /**\n   * Validate model availability\n   */\n  public async validateModelAvailability(modelId: string): Promise<boolean> {\n    try {\n      const models = await this.getAvailableModels();\n      return models.some(model => model.id === modelId);\n    } catch (error) {\n      logger.error('Failed to validate model availability', { modelId, error });\n      return false;\n    }\n  }\n\n  /**\n   * Get model by ID\n   */\n  public async getModel(modelId: string): Promise<OpenRouterModel | null> {\n    try {\n      const models = await this.getAvailableModels();\n      return models.find(model => model.id === modelId) ?? null;\n    } catch (error) {\n      logger.error('Failed to get model', { modelId, error });\n      return null;\n    }\n  }\n\n  /**\n   * Refresh models cache\n   */\n  public async refreshCache(): Promise<void> {\n    try {\n      const models = await this.fetchModelsFromAPI();\n      this.saveToCache(models);\n      logger.info('Models cache refreshed', { modelCount: models.length });\n    } catch (error) {\n      logger.error('Failed to refresh models cache', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if cache is valid\n   */\n  private isCacheValid(): boolean {\n    if (!this.cache) return false;\n    return Date.now() - this.cache.timestamp < CACHE_DURATION;\n  }\n\n  /**\n   * Load models from cache\n   */\n  private loadFromCache(): void {\n    try {\n      const cached = localStorage.getItem(CACHE_KEY);\n      if (cached) {\n        const parsed = JSON.parse(cached);\n        this.cache = parsed;\n      }\n    } catch (error) {\n      logger.warn('Failed to load models from cache', { error });\n      this.cache = null;\n    }\n  }\n\n  /**\n   * Save models to cache\n   */\n  private saveToCache(models: OpenRouterModel[]): void {\n    try {\n      this.cache = {\n        models,\n        timestamp: Date.now(),\n      };\n      localStorage.setItem(CACHE_KEY, JSON.stringify(this.cache));\n    } catch (error) {\n      logger.warn('Failed to save models to cache', { error });\n    }\n  }\n\n  /**\n   * Fetch models from OpenRouter API via Edge Functions\n   */\n  private async fetchModelsFromAPI(): Promise<OpenRouterModel[]> {\n    try {\n      const response = await withRetry(\n        async () => {\n          const res = await fetch('/api/ai/models', {\n            method: 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n          });\n          if (!res.ok) {\n            // If response is not ok, throw an error to trigger retry.\n            // Attach status to error for intelligent retry in withRetry.\n            const errorText = await res.text();\n            const error = new Error(`Failed to fetch models: ${res.status} ${errorText}`);\n            (error as any).status = res.status; // Attach status for retry logic\n            throw error;\n          }\n          return res;\n        },\n        { logLabel: 'OpenRouterModelsService.fetchModelsFromAPI' },\n      );\n\n      const data = await response.json();\n\n      if (!data.models || !Array.isArray(data.models)) {\n        throw new Error('Invalid response format from API');\n      }\n\n      logger.info('Fetched models from Edge API', { modelCount: data.models.length });\n      return data.models;\n    } catch (error) {\n      logger.error('Failed to fetch models from Edge API after multiple retries', { error });\n\n      // Return fallback models for development/offline scenarios\n      logger.warn('Using fallback models due to API error');\n      return FALLBACK_MODELS;\n    }\n  }\n}\n\n// Export singleton instance\nexport const openRouterModelsService = OpenRouterModelsService.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\LazyMDEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\LazyRecharts.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_props' is defined but never used.","line":17,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ScrollArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\display\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\forms\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\AppBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\BottomNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\layout\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\pwa\\PWAStatus.tsx","messages":[],"suppressedMessages":[{"ruleId":"react/hook-use-state","severity":1,"message":"useState call is not destructured into value + setter pair","line":15,"column":9,"nodeType":"ArrayPattern","messageId":"useStateErrorMessage","endLine":15,"endColumn":20,"suggestions":[{"messageId":"suggestMemo","fix":{"range":[191,637],"text":", useMemo } from 'react';\n\nimport { installPromptManager } from '@/lib/pwa/install-prompt';\nimport { offlineManager } from '@/lib/pwa/offline-manager';\nimport { Button } from '@/shared/components/ui/Button';\n\nexport const PWAStatus: React.FC = () => {\n  const [isOffline, setIsOffline] = useState(offlineManager.isOffline());\n  const [canInstall, setCanInstall] = useState(installPromptManager.canInstall());\n  const isSyncing = React.useMemo(() => false, [])"},"desc":"Replace useState call with useMemo"},{"messageId":"suggestPair","fix":{"range":[599,610],"text":"[isSyncing, setIsSyncing]"},"desc":"Destructure useState call into value + setter pair"}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\MetricCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\Toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\__tests__\\Button.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\components\\ui\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\utils\\__tests__\\validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\utils\\chapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\shared\\utils\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\a11y-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\accessibility-audit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\header-debug.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\run-a11y-scan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\test\\utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\@uiw\\react-md-editor.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\__tests__\\guards.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\__tests__\\schemas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\ai-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\character-guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\character-schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\embeddings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\types\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\utils\\performance.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\git\\do-novelist-ai\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
