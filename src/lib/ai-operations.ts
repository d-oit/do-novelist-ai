/**
 * AI Operations
 * Business logic for specific AI tasks: text generation, plot analysis, etc.
 */

import {
  generateBookCover as serviceGenerateBookCover,
  generateChapterIllustration as serviceGenerateChapterIllustration,
} from '@/features/generation/services/imageGenerationService';
import { withCache } from '@/lib/cache';
import type { Chapter, RefineOptions } from '@/types/index';

import {
  openrouterClient,
  getModelName,
  aiLogger,
  isTestEnvironment,
  isValidOutline,
  executeWithFallback,
  config,
} from './ai-core';

/**
 * Generate outline for a book idea
 * Now uses serverless API endpoint for security
 */
const _generateOutline = async (
  idea: string,
  style: string,
): Promise<{ title: string; chapters: Partial<Chapter>[] }> => {
  const operationLogger = aiLogger.child({ operation: 'generateOutline', ideaLength: idea.length });

  if (isTestEnvironment()) {
    operationLogger.info('Returning mock outline for test environment');
    return {
      title: 'Mock Project: Agent Test Story',
      chapters: [
        { orderIndex: 1, title: 'Chapter 1: The Beginning', summary: 'Introduction to the story' },
        { orderIndex: 2, title: 'Chapter 2: The Journey', summary: 'The adventure continues' },
        { orderIndex: 3, title: 'Chapter 3: The End', summary: 'The conclusion' },
      ],
    };
  }

  operationLogger.debug('Generating outline via serverless API', {
    style,
    ideaPreview: idea.substring(0, 100),
  });

  try {
    const response = await fetch('/api/ai/outline', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        idea,
        style,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { title: string; chapters: Partial<Chapter>[] };

    if (!isValidOutline(data)) {
      throw new Error('Invalid outline structure received from API');
    }

    operationLogger.info('Outline generated successfully', {
      title: data.title,
      chapterCount: data.chapters?.length ?? 0,
    });

    return data;
  } catch (error) {
    operationLogger.error('Outline generation failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

export const generateOutline = withCache(_generateOutline, 'generateOutline');

/**
 * Write chapter content
 * Now uses serverless API endpoint for security
 */
export const writeChapterContent = async (
  chapterTitle: string,
  chapterSummary: string,
  style: string,
  previousChapterSummary?: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# ${chapterTitle}

This is a test chapter content generated by the mock AI service. It contains enough text to meet the minimum requirements for the chapter writing functionality.

The story continues with detailed narrative, character development, and plot progression that would normally be generated by the AI Gateway service.`;
  }

  try {
    const response = await fetch('/api/ai/chapter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chapterTitle,
        chapterSummary,
        style,
        previousChapterSummary,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { content: string };
    return data.content ?? '';
  } catch (error) {
    aiLogger.error('Chapter writing failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Continue writing from current content
 * Now uses serverless API endpoint for security
 */
export const continueWriting = async (
  currentContent: string,
  chapterSummary: string,
  style: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Continued Chapter

The story continues from where it left off, maintaining narrative consistency and character voice.

The adventure unfolds with new challenges and developments that propel the plot forward in an engaging manner.`;
  }

  try {
    const response = await fetch('/api/ai/continue', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        currentContent,
        chapterSummary,
        style,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { content: string };
    return data.content ?? '';
  } catch (error) {
    aiLogger.error('Continue writing failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Refine chapter content
 */
export const refineChapterContent = async (
  content: string,
  chapterSummary: string,
  style: string,
  options: RefineOptions,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Refined Chapter

This chapter has been refined with improved pacing, better dialogue, and enhanced descriptions.

## Changes Made:
- Improved paragraph flow
- Enhanced character voice
- Added sensory details
- Tightened prose`;
  }

  return executeWithFallback(async provider => {
    const complexity =
      options.model?.includes('pro') || options.model?.includes('advanced')
        ? 'advanced'
        : 'standard';
    const model = getModelName(provider, complexity);

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
Refine the following chapter content.
Style: ${style}
Goal: ${chapterSummary}
Instructions: Improve flow, prose, and dialogue. Fix grammar. Maintain tone. Do NOT change plot.
Content: ${content}`,
        },
      ],
      temperature: options.temperature,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? content;
  }, 'refineChapterContent');
};

/**
 * Analyze consistency across chapters
 */
export const analyzeConsistency = async (chapters: Chapter[], style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return `## Consistency Analysis

1. Character names are consistent throughout
2. Timeline is coherent
3. No major plot holes detected
4. Dialogue matches character personalities

Overall: The story shows good consistency with minor suggestions for improvement.`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'fast');
    const bookContext = chapters
      .map(c => `Ch ${c.orderIndex} (${c.title}): ${c.summary}`)
      .join('\n');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
Analyze this outline for inconsistencies, plot holes, or tonal shifts.
Style: ${style}
Outline: ${bookContext}
INSTRUCTIONS: Identify up to 3 issues. For EACH, provide a "SUGGESTED FIX".`,
        },
      ],
      temperature: 0.3,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? 'No issues found.';
  }, 'analyzeConsistency');
};

/**
 * Brainstorm ideas
 * Uses API route to avoid CORS issues in browser
 */
export const brainstormProject = async (
  context: string,
  field: 'title' | 'style' | 'idea',
): Promise<string> => {
  if (isTestEnvironment()) {
    if (field === 'title') return 'Mock Project: Agent Test Story';
    if (field === 'style') return 'Science Fiction';
    return '## Brainstorming Notes\n\n### Themes\n- Friendship and teamwork\n- Overcoming adversity\n- Discovery and exploration\n\n### Character Ideas\n- Protagonist with unique abilities\n- Loyal companion\n- Formidable antagonist\n\n### Plot Ideas\n- Quest to save the world\n- Journey of self-discovery\n- Mystery to solve';
  }

  const response = await fetch('/api/ai/brainstorm', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      context: context.substring(0, 50000),
      field,
      provider: config.defaultProvider,
    }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    aiLogger.error('Brainstorm API error', {
      status: response.status,
      error: error.error || error.message,
    });
    throw new Error(error.error || error.message || `API request failed: ${response.status}`);
  }

  const data = await response.json();
  return data.text?.trim().replace(/^"|"$/g, '') ?? '';
};

/**
 * Generate cover image (Google only - has Imagen support)
 * Returns a base64-encoded image for use in the frontend
 */
export const generateCoverImage = async (
  _title: string,
  _style: string,
  _idea: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    return await serviceGenerateBookCover(_title, _idea, _style);
  } catch (error) {
    aiLogger.error('Cover image generation failed', {
      operation: 'generateCoverImage',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Generate chapter illustration (Google only - has Imagen support)
 * Returns a base64-encoded image for use in the frontend
 */
export const generateChapterIllustration = async (
  _title: string,
  _summary: string,
  _style: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    // Reuse generateBookCover logic for now but pass summary
    // In a real scenario we might want a different aspect ratio or prompt
    return await serviceGenerateChapterIllustration(_title, _summary, _style);
  } catch (error) {
    aiLogger.error('Chapter illustration failed', {
      operation: 'generateChapterIllustration',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Translate content
 */
export const translateContent = async (
  content: string,
  targetLanguage: string,
): Promise<string> => {
  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'fast');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Translate markdown content to ${targetLanguage}. Maintain formatting and tone.\n\nContent:\n${content}`,
        },
      ],
      temperature: 0.3,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'translateContent');
};

/**
 * Develop characters
 */
export const developCharacters = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '**Alice**: A brilliant physicist\n**Bob**: A skilled engineer\n**Charlie**: A mysterious stranger';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Create a character cast list for: ${idea}\nStyle: ${style}\nOutput Name, Role, Motivation, Conflict.`,
        },
      ],
      temperature: 0.8,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'developCharacters');
};

/**
 * Build world
 */
export const buildWorld = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '## Setting\nA futuristic space station orbiting a distant planet.\n\n## Technology\nAdvanced AI systems and FTL travel.\n\n## Society\nA diverse coalition of species working together.';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Expand setting/lore for: ${idea}\nStyle: ${style}\nFocus on rules, atmosphere, locations.`,
        },
      ],
      temperature: 0.85,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'buildWorld');
};

/**
 * Enhance plot
 */
export const enhancePlot = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '## Plot Development\n1. Opening: Establish the protagonist and setting\n2. Rising Action: Conflict emerges\n3. Climax: The main conflict reaches its peak\n4. Falling Action: Consequences of the climax\n5. Resolution: The story concludes';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'advanced');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Inject conflict and structure into: ${idea}\nStyle: ${style}\nProvide Inciting Incident, Twist, Climax setup.`,
        },
      ],
      temperature: 0.7,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'enhancePlot');
};

/**
 * Polish dialogue
 */
export const polishDialogue = async (content: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Polished Script

"Hello there," said Bob with a warm smile.

"Hi, Alice. Ready for the mission?" she replied, checking her equipment.

"Absolutely. This is going to be our greatest adventure yet."`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Rewrite ONLY dialogue to be subtext-rich and distinct.\nStyle: ${style}\nText:\n${content}`,
        },
      ],
      temperature: 0.6,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'polishDialogue');
};
