/**
 * AI Operations
 * Business logic for specific AI tasks: text generation, plot analysis, etc.
 * All operations now use secure serverless API endpoints with context injection
 */

import { settingsService } from '@/features/settings/services/settingsService';
import { withCache } from '@/lib/cache';
import { ContextAwarePrompts } from '@/lib/context';
import type { Chapter, RefineOptions, Project } from '@/types/index';

import { aiLogger, isTestEnvironment, isValidOutline, config } from './ai-core';

/**
 * Generate outline for a book idea
 * Now uses serverless API endpoint with context injection for security and consistency
 */
const _generateOutline = async (
  idea: string,
  style: string,
  project?: Project,
): Promise<{ title: string; chapters: Partial<Chapter>[] }> => {
  const operationLogger = aiLogger.child({ operation: 'generateOutline', ideaLength: idea.length });

  if (isTestEnvironment()) {
    operationLogger.info('Returning mock outline for test environment');
    return {
      title: 'Mock Project: Agent Test Story',
      chapters: [
        { orderIndex: 1, title: 'Chapter 1: The Beginning', summary: 'Introduction to the story' },
        { orderIndex: 2, title: 'Chapter 2: The Journey', summary: 'The adventure continues' },
        { orderIndex: 3, title: 'Chapter 3: The End', summary: 'The conclusion' },
      ],
    };
  }

  operationLogger.debug('Generating outline via serverless API with context', {
    style,
    ideaPreview: idea.substring(0, 100),
    hasProject: !!project,
  });

  try {
    let enhancedPrompt;

    const settings = settingsService.load();

    if (project && settings.enableContextInjection) {
      const contextPrompts = new ContextAwarePrompts(project);
      enhancedPrompt = await contextPrompts.createOutlinePrompt(idea, style);

      operationLogger.debug('Using context-aware prompt', {
        estimatedTokens: enhancedPrompt.estimatedTokens,
        hasContext: !!enhancedPrompt.context,
        contextEnabled: true,
        tokenLimit: settings.contextTokenLimit,
      });
    } else if (project) {
      operationLogger.debug('Context injection disabled by user settings', {
        contextEnabled: false,
      });
    }

    const response = await fetch('/api/ai/outline', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        idea,
        style,
        provider: config.defaultProvider,
        // Include enhanced prompts if available
        ...(enhancedPrompt && {
          systemPrompt: enhancedPrompt.systemPrompt,
          userPrompt: enhancedPrompt.userPrompt,
        }),
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { title: string; chapters: Partial<Chapter>[] };

    if (!isValidOutline(data)) {
      throw new Error('Invalid outline structure received from API');
    }

    operationLogger.info('Outline generated successfully', {
      title: data.title,
      chapterCount: data.chapters?.length ?? 0,
      contextAware: !!project && settings.enableContextInjection,
    });

    return data;
  } catch (error) {
    operationLogger.error('Outline generation failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

export const generateOutline = withCache(_generateOutline, 'generateOutline');

/**
 * Write chapter content
 * Now uses serverless API endpoint with context injection for security and consistency
 */
export const writeChapterContent = async (
  chapterTitle: string,
  chapterSummary: string,
  style: string,
  previousChapterSummary?: string,
  project?: Project,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# ${chapterTitle}

This is a test chapter content generated by the mock AI service. It contains enough text to meet the minimum requirements for the chapter writing functionality.

The story continues with detailed narrative, character development, and plot progression that would normally be generated by the AI Gateway service.`;
  }

  try {
    let enhancedPrompt;
    const settings = settingsService.load();

    if (project && settings.enableContextInjection) {
      const contextPrompts = new ContextAwarePrompts(project);
      enhancedPrompt = await contextPrompts.createChapterPrompt(
        chapterTitle,
        chapterSummary,
        style,
        previousChapterSummary,
      );

      aiLogger.debug('Using context-aware chapter prompt', {
        estimatedTokens: enhancedPrompt.estimatedTokens,
        hasContext: !!enhancedPrompt.context,
        contextEnabled: true,
        tokenLimit: settings.contextTokenLimit,
      });
    } else if (project) {
      aiLogger.debug('Context injection disabled for chapter writing', {
        contextEnabled: false,
      });
    }

    const response = await fetch('/api/ai/chapter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chapterTitle,
        chapterSummary,
        style,
        previousChapterSummary,
        provider: config.defaultProvider,
        // Include enhanced prompts if available
        ...(enhancedPrompt && {
          systemPrompt: enhancedPrompt.systemPrompt,
          userPrompt: enhancedPrompt.userPrompt,
        }),
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { content: string };

    aiLogger.info('Chapter written successfully', {
      chapterTitle,
      contentLength: data.content?.length || 0,
      contextAware: !!project && settings.enableContextInjection,
    });

    return data.content ?? '';
  } catch (error) {
    aiLogger.error('Chapter writing failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Continue writing from current content
 * Now uses serverless API endpoint for security
 */
export const continueWriting = async (
  currentContent: string,
  chapterSummary: string,
  style: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Continued Chapter

The story continues from where it left off, maintaining narrative consistency and character voice.

The adventure unfolds with new challenges and developments that propel the plot forward in an engaging manner.`;
  }

  try {
    const response = await fetch('/api/ai/continue', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        currentContent,
        chapterSummary,
        style,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { content: string };
    return data.content ?? '';
  } catch (error) {
    aiLogger.error('Continue writing failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Refine chapter content
 * Now uses serverless API endpoint for security
 */
export const refineChapterContent = async (
  content: string,
  chapterSummary: string,
  style: string,
  options: RefineOptions,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Refined Chapter

This chapter has been refined with improved pacing, better dialogue, and enhanced descriptions.

## Changes Made:
- Improved paragraph flow
- Enhanced character voice
- Added sensory details
- Tightened prose`;
  }

  try {
    const response = await fetch('/api/ai/refine', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content,
        chapterSummary,
        style,
        options,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { content: string };
    return data.content ?? content;
  } catch (error) {
    aiLogger.error('Content refinement failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Analyze consistency across chapters
 * Now uses serverless API endpoint with context injection for security and consistency
 */
export const analyzeConsistency = async (
  chapters: Chapter[],
  style: string,
  project?: Project,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `## Consistency Analysis

1. Character names are consistent throughout
2. Timeline is coherent
3. No major plot holes detected
4. Dialogue matches character personalities

Overall: The story shows good consistency with minor suggestions for improvement.`;
  }

  try {
    let enhancedPrompt;
    const settings = settingsService.load();

    if (project && settings.enableContextInjection) {
      const contextPrompts = new ContextAwarePrompts(project);
      enhancedPrompt = await contextPrompts.createConsistencyPrompt(chapters);

      aiLogger.debug('Using context-aware consistency prompt', {
        estimatedTokens: enhancedPrompt.estimatedTokens,
        hasContext: !!enhancedPrompt.context,
        contextEnabled: true,
        tokenLimit: settings.contextTokenLimit,
      });
    } else if (project) {
      aiLogger.debug('Context injection disabled for consistency analysis', {
        contextEnabled: false,
      });
    }

    const response = await fetch('/api/ai/consistency', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chapters: chapters.map(c => ({
          orderIndex: c.orderIndex,
          title: c.title,
          summary: c.summary,
        })),
        style,
        provider: config.defaultProvider,
        // Include enhanced prompts if available
        ...(enhancedPrompt && {
          systemPrompt: enhancedPrompt.systemPrompt,
          userPrompt: enhancedPrompt.userPrompt,
        }),
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { analysis: string };

    aiLogger.info('Consistency analysis completed', {
      chaptersAnalyzed: chapters.length,
      analysisLength: data.analysis?.length || 0,
      contextAware: !!project && settings.enableContextInjection,
    });

    return data.analysis ?? 'No issues found.';
  } catch (error) {
    aiLogger.error('Consistency analysis failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Brainstorm ideas
 * Uses API route to avoid CORS issues in browser
 */
export const brainstormProject = async (
  context: string,
  field: 'title' | 'style' | 'idea',
): Promise<string> => {
  if (isTestEnvironment()) {
    if (field === 'title') return 'Mock Project: Agent Test Story';
    if (field === 'style') return 'Science Fiction';
    return '## Brainstorming Notes\n\n### Themes\n- Friendship and teamwork\n- Overcoming adversity\n- Discovery and exploration\n\n### Character Ideas\n- Protagonist with unique abilities\n- Loyal companion\n- Formidable antagonist\n\n### Plot Ideas\n- Quest to save the world\n- Journey of self-discovery\n- Mystery to solve';
  }

  const response = await fetch('/api/ai/brainstorm', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      context: context.substring(0, 50000),
      field,
      provider: config.defaultProvider,
    }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    aiLogger.error('Brainstorm API error', {
      status: response.status,
      error: error.error || error.message,
    });
    throw new Error(error.error || error.message || `API request failed: ${response.status}`);
  }

  const data = await response.json();
  return data.text?.trim().replace(/^"|"$/g, '') ?? '';
};

/**
 * Generate cover image
 * Now uses serverless API endpoint for security
 */
export const generateCoverImage = async (
  title: string,
  style: string,
  idea: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    const response = await fetch('/api/ai/image', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'cover',
        title,
        description: idea,
        style,
        provider: 'openai',
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      aiLogger.error('Cover image generation failed', { error: error.error });
      return null;
    }

    const data = (await response.json()) as { imageUrl: string };
    return data.imageUrl ?? null;
  } catch (error) {
    aiLogger.error('Cover image generation failed', {
      operation: 'generateCoverImage',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Generate chapter illustration
 * Now uses serverless API endpoint for security
 */
export const generateChapterIllustration = async (
  title: string,
  summary: string,
  style: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    const response = await fetch('/api/ai/image', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'illustration',
        title,
        description: summary,
        style,
        provider: 'openai',
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      aiLogger.error('Chapter illustration failed', { error: error.error });
      return null;
    }

    const data = (await response.json()) as { imageUrl: string };
    return data.imageUrl ?? null;
  } catch (error) {
    aiLogger.error('Chapter illustration failed', {
      operation: 'generateChapterIllustration',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Translate content
 * Now uses serverless API endpoint for security
 */
export const translateContent = async (
  content: string,
  targetLanguage: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `[Translated to ${targetLanguage}] ${content}`;
  }

  try {
    const response = await fetch('/api/ai/translate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content,
        targetLanguage,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { translatedContent: string };
    return data.translatedContent ?? '';
  } catch (error) {
    aiLogger.error('Translation failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Develop characters
 * Now uses serverless API endpoint with context injection for security and consistency
 */
export const developCharacters = async (
  idea: string,
  style: string,
  project?: Project,
): Promise<string> => {
  if (isTestEnvironment()) {
    return '**Alice**: A brilliant physicist\n**Bob**: A skilled engineer\n**Charlie**: A mysterious stranger';
  }

  try {
    let enhancedPrompt;
    const settings = settingsService.load();

    if (project && settings.enableContextInjection) {
      const contextPrompts = new ContextAwarePrompts(project);
      enhancedPrompt = await contextPrompts.createCharacterPrompt(idea, style);

      aiLogger.debug('Using context-aware character prompt', {
        estimatedTokens: enhancedPrompt.estimatedTokens,
        hasContext: !!enhancedPrompt.context,
        contextEnabled: true,
        tokenLimit: settings.contextTokenLimit,
      });
    } else if (project) {
      aiLogger.debug('Context injection disabled for character development', {
        contextEnabled: false,
      });
    }

    const response = await fetch('/api/ai/characters', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        idea,
        style,
        provider: config.defaultProvider,
        // Include enhanced prompts if available
        ...(enhancedPrompt && {
          systemPrompt: enhancedPrompt.systemPrompt,
          userPrompt: enhancedPrompt.userPrompt,
        }),
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { characters: string };

    aiLogger.info('Characters developed successfully', {
      charactersLength: data.characters?.length || 0,
      contextAware: !!project && settings.enableContextInjection,
    });

    return data.characters ?? '';
  } catch (error) {
    aiLogger.error('Character development failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Build world
 * Now uses serverless API endpoint for security
 */
export const buildWorld = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '## Setting\nA futuristic space station orbiting a distant planet.\n\n## Technology\nAdvanced AI systems and FTL travel.\n\n## Society\nA diverse coalition of species working together.';
  }

  try {
    const response = await fetch('/api/ai/world', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        idea,
        style,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { worldBuilding: string };
    return data.worldBuilding ?? '';
  } catch (error) {
    aiLogger.error('World building failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};

/**
 * Polish dialogue
 * Now uses serverless API endpoint for security
 */
export const polishDialogue = async (content: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Polished Script

"Hello there," said Bob with a warm smile.

"Hi, Alice. Ready for the mission?" she replied, checking her equipment.

"Absolutely. This is going to be our greatest adventure yet."`;
  }

  try {
    const response = await fetch('/api/ai/dialogue', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content,
        style,
        provider: config.defaultProvider,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(error.error || `API request failed: ${response.status}`);
    }

    const data = (await response.json()) as { polishedContent: string };
    return data.polishedContent ?? '';
  } catch (error) {
    aiLogger.error('Dialogue polishing failed', {
      error: error instanceof Error ? error.message : String(error),
    });
    throw error;
  }
};
