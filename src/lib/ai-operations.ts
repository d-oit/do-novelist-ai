/**
 * AI Operations
 * Business logic for specific AI tasks: text generation, plot analysis, etc.
 */

import {
  generateBookCover as serviceGenerateBookCover,
  generateChapterIllustration as serviceGenerateChapterIllustration,
} from '@/features/generation/services/imageGenerationService';
import { withCache } from '@/lib/cache';
import { createAIError } from '@/lib/errors/error-types';
import type { Chapter, RefineOptions } from '@/types/index';

import {
  openrouterClient,
  getModelName,
  aiLogger,
  isTestEnvironment,
  isValidOutline,
  executeWithFallback,
  config,
} from './ai-core';

/**
 * Generate outline for a book idea
 */
const _generateOutline = async (
  idea: string,
  style: string,
): Promise<{ title: string; chapters: Partial<Chapter>[] }> => {
  const operationLogger = aiLogger.child({ operation: 'generateOutline', ideaLength: idea.length });

  if (isTestEnvironment()) {
    operationLogger.info('Returning mock outline for test environment');
    return {
      title: 'Mock Project: Agent Test Story',
      chapters: [
        { orderIndex: 1, title: 'Chapter 1: The Beginning', summary: 'Introduction to the story' },
        { orderIndex: 2, title: 'Chapter 2: The Journey', summary: 'The adventure continues' },
        { orderIndex: 3, title: 'Chapter 3: The End', summary: 'The conclusion' },
      ],
    };
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'system',
          content: `You are an expert Novel Architect.
Your goal is to take a vague book idea and structurize it into a compelling chapter outline.
The style of the book is: ${style}.
Adhere to the "Hero's Journey" or "Save the Cat" beat sheets if applicable to the genre.`,
        },
        {
          role: 'user',
          content: `Create a title and a chapter outline for this idea: "${idea}"

Return a JSON object with this structure:
{
  "title": "Book Title",
  "chapters": [
    {
      "orderIndex": 1,
      "title": "Chapter Title",
      "summary": "Detailed paragraph summary of what happens in this chapter"
    }
  ]
}`,
        },
      ],
      temperature: 0.7,
      stream: false,
    });

    operationLogger.debug('Generating outline', {
      provider,
      style,
      ideaPreview: idea.substring(0, 100),
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    try {
      const parsed = JSON.parse(responseText) as { title: string; chapters: Partial<Chapter>[] };
      if (!isValidOutline(parsed)) {
        throw new Error('Invalid outline structure received from AI');
      }
      operationLogger.info('Outline generated successfully', {
        provider,
        title: parsed.title,
        chapterCount: parsed.chapters?.length ?? 0,
      });
      return parsed;
    } catch (parseError) {
      operationLogger.warn('JSON parsing failed, trying to extract from response', {
        provider,
        error: parseError instanceof Error ? parseError.message : String(parseError),
        responsePreview: responseText.substring(0, 200),
      });

      const jsonMatch = /\{[\s\S]*\}/.exec(responseText);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[0]) as {
            title: string;
            chapters: Partial<Chapter>[];
          };
          if (!isValidOutline(parsed)) {
            throw new Error('Invalid outline structure received from AI');
          }
          operationLogger.info('Successfully extracted JSON from response', {
            provider,
            title: parsed.title,
            chapterCount: parsed.chapters?.length ?? 0,
          });
          return parsed;
        } catch (secondParseError) {
          operationLogger.error('Failed to parse extracted JSON', {
            provider,
            error:
              secondParseError instanceof Error
                ? secondParseError.message
                : String(secondParseError),
          });
        }
      }

      const error = createAIError('Failed to parse outline response as JSON', {
        provider,
        operation: 'generateOutline',
        cause: parseError instanceof Error ? parseError : undefined,
        context: {
          responsePreview: responseText.substring(0, 500),
          idea: idea.substring(0, 100),
          style,
        },
      });

      throw error;
    }
  }, 'generateOutline');
};

export const generateOutline = withCache(_generateOutline, 'generateOutline');

/**
 * Write chapter content
 */
export const writeChapterContent = async (
  chapterTitle: string,
  chapterSummary: string,
  style: string,
  previousChapterSummary?: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# ${chapterTitle}

This is a test chapter content generated by the mock AI service. It contains enough text to meet the minimum requirements for the chapter writing functionality.

The story continues with detailed narrative, character development, and plot progression that would normally be generated by the AI Gateway service.`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
Write the full content for the chapter: "${chapterTitle}".
Context / Summary: ${chapterSummary}
${previousChapterSummary != null ? `Previously: ${previousChapterSummary}` : ''}
Style: ${style}.
Write in Markdown. Focus on "Show, Don't Tell". Use sensory details.
Output only the chapter content.`,
        },
      ],
      temperature: 0.7,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'writeChapterContent');
};

/**
 * Continue writing from current content
 */
export const continueWriting = async (
  currentContent: string,
  chapterSummary: string,
  style: string,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Continued Chapter

The story continues from where it left off, maintaining narrative consistency and character voice.

The adventure unfolds with new challenges and developments that propel the plot forward in an engaging manner.`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');
    const context = currentContent.slice(-3000);

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
You are a co-author. Continue the story.
Style: ${style}
Goal: ${chapterSummary}
Rules: Seamlessly continue narrative. Maintain tone. Write 300-500 words. Output ONLY new content.
Context: ...${context}`,
        },
      ],
      temperature: 0.75,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'continueWriting');
};

/**
 * Refine chapter content
 */
export const refineChapterContent = async (
  content: string,
  chapterSummary: string,
  style: string,
  options: RefineOptions,
): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Refined Chapter

This chapter has been refined with improved pacing, better dialogue, and enhanced descriptions.

## Changes Made:
- Improved paragraph flow
- Enhanced character voice
- Added sensory details
- Tightened prose`;
  }

  return executeWithFallback(async provider => {
    const complexity =
      options.model?.includes('pro') || options.model?.includes('advanced')
        ? 'advanced'
        : 'standard';
    const model = getModelName(provider, complexity);

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
Refine the following chapter content.
Style: ${style}
Goal: ${chapterSummary}
Instructions: Improve flow, prose, and dialogue. Fix grammar. Maintain tone. Do NOT change plot.
Content: ${content}`,
        },
      ],
      temperature: options.temperature,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? content;
  }, 'refineChapterContent');
};

/**
 * Analyze consistency across chapters
 */
export const analyzeConsistency = async (chapters: Chapter[], style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return `## Consistency Analysis

1. Character names are consistent throughout
2. Timeline is coherent
3. No major plot holes detected
4. Dialogue matches character personalities

Overall: The story shows good consistency with minor suggestions for improvement.`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'fast');
    const bookContext = chapters
      .map(c => `Ch ${c.orderIndex} (${c.title}): ${c.summary}`)
      .join('\n');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `
Analyze this outline for inconsistencies, plot holes, or tonal shifts.
Style: ${style}
Outline: ${bookContext}
INSTRUCTIONS: Identify up to 3 issues. For EACH, provide a "SUGGESTED FIX".`,
        },
      ],
      temperature: 0.3,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? 'No issues found.';
  }, 'analyzeConsistency');
};

/**
 * Brainstorm ideas
 * Uses API route to avoid CORS issues in browser
 */
export const brainstormProject = async (
  context: string,
  field: 'title' | 'style' | 'idea',
): Promise<string> => {
  if (isTestEnvironment()) {
    if (field === 'title') return 'Mock Project: Agent Test Story';
    if (field === 'style') return 'Science Fiction';
    return '## Brainstorming Notes\n\n### Themes\n- Friendship and teamwork\n- Overcoming adversity\n- Discovery and exploration\n\n### Character Ideas\n- Protagonist with unique abilities\n- Loyal companion\n- Formidable antagonist\n\n### Plot Ideas\n- Quest to save the world\n- Journey of self-discovery\n- Mystery to solve';
  }

  const response = await fetch('/api/ai/brainstorm', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      context: context.substring(0, 50000),
      field,
      provider: config.defaultProvider,
    }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    aiLogger.error('Brainstorm API error', {
      status: response.status,
      error: error.error || error.message,
    });
    throw new Error(error.error || error.message || `API request failed: ${response.status}`);
  }

  const data = await response.json();
  return data.text?.trim().replace(/^"|"$/g, '') ?? '';
};

/**
 * Generate cover image (Google only - has Imagen support)
 * Returns a base64-encoded image for use in the frontend
 */
export const generateCoverImage = async (
  _title: string,
  _style: string,
  _idea: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    return await serviceGenerateBookCover(_title, _idea, _style);
  } catch (error) {
    aiLogger.error('Cover image generation failed', {
      operation: 'generateCoverImage',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Generate chapter illustration (Google only - has Imagen support)
 * Returns a base64-encoded image for use in the frontend
 */
export const generateChapterIllustration = async (
  _title: string,
  _summary: string,
  _style: string,
): Promise<string | null> => {
  try {
    if (isTestEnvironment()) {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    }

    // Reuse generateBookCover logic for now but pass summary
    // In a real scenario we might want a different aspect ratio or prompt
    return await serviceGenerateChapterIllustration(_title, _summary, _style);
  } catch (error) {
    aiLogger.error('Chapter illustration failed', {
      operation: 'generateChapterIllustration',
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
};

/**
 * Translate content
 */
export const translateContent = async (
  content: string,
  targetLanguage: string,
): Promise<string> => {
  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'fast');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Translate markdown content to ${targetLanguage}. Maintain formatting and tone.\n\nContent:\n${content}`,
        },
      ],
      temperature: 0.3,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'translateContent');
};

/**
 * Develop characters
 */
export const developCharacters = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '**Alice**: A brilliant physicist\n**Bob**: A skilled engineer\n**Charlie**: A mysterious stranger';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Create a character cast list for: ${idea}\nStyle: ${style}\nOutput Name, Role, Motivation, Conflict.`,
        },
      ],
      temperature: 0.8,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'developCharacters');
};

/**
 * Build world
 */
export const buildWorld = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '## Setting\nA futuristic space station orbiting a distant planet.\n\n## Technology\nAdvanced AI systems and FTL travel.\n\n## Society\nA diverse coalition of species working together.';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Expand setting/lore for: ${idea}\nStyle: ${style}\nFocus on rules, atmosphere, locations.`,
        },
      ],
      temperature: 0.85,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'buildWorld');
};

/**
 * Enhance plot
 */
export const enhancePlot = async (idea: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return '## Plot Development\n1. Opening: Establish the protagonist and setting\n2. Rising Action: Conflict emerges\n3. Climax: The main conflict reaches its peak\n4. Falling Action: Consequences of the climax\n5. Resolution: The story concludes';
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'advanced');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Inject conflict and structure into: ${idea}\nStyle: ${style}\nProvide Inciting Incident, Twist, Climax setup.`,
        },
      ],
      temperature: 0.7,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'enhancePlot');
};

/**
 * Polish dialogue
 */
export const polishDialogue = async (content: string, style: string): Promise<string> => {
  if (isTestEnvironment()) {
    return `# Polished Script

"Hello there," said Bob with a warm smile.

"Hi, Alice. Ready for the mission?" she replied, checking her equipment.

"Absolutely. This is going to be our greatest adventure yet."`;
  }

  return executeWithFallback(async provider => {
    const model = getModelName(provider, 'standard');

    const response = await openrouterClient.chat.send({
      model,
      messages: [
        {
          role: 'user',
          content: `Rewrite ONLY dialogue to be subtext-rich and distinct.\nStyle: ${style}\nText:\n${content}`,
        },
      ],
      temperature: 0.6,
      stream: false,
    });

    const responseText =
      typeof response.choices[0]?.message.content === 'string'
        ? response.choices[0].message.content
        : '';

    return responseText ?? '';
  }, 'polishDialogue');
};
